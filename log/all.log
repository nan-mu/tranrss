2024-02-22T17:31:34.082777945+08:00 - start
2024-02-22T17:31:34.082833564+08:00 - 访问 https://rustcc.cn/rss 开始
2024-02-22T17:31:34.082913936+08:00 - 访问 https://rustmagazine.org/feed.xml 开始
2024-02-22T17:31:34.082949491+08:00 - 访问 https://readrust.net/all/feed.rss 开始
2024-02-22T17:31:34.178809667+08:00 - starting new connection: https://rustmagazine.org/
2024-02-22T17:31:34.180201039+08:00 - starting new connection: https://readrust.net/
2024-02-22T17:31:34.181708862+08:00 - starting new connection: https://rustcc.cn/
2024-02-22T17:31:39.000409020+08:00 - RSS2
2024-02-22T17:31:39.009829289+08:00 - Atom
2024-02-22T17:31:39.018082336+08:00 - RSS2
2024-02-22T18:26:31.503174722+08:00 - start
2024-02-22T18:26:31.503302711+08:00 - 访问 https://rustcc.cn/rss 开始
2024-02-22T18:26:31.503386655+08:00 - 访问 https://rustmagazine.org/feed.xml 开始
2024-02-22T18:26:31.503406855+08:00 - 访问 https://readrust.net/all/feed.rss 开始
2024-02-22T18:26:31.598818822+08:00 - starting new connection: https://rustmagazine.org/
2024-02-22T18:26:31.601886144+08:00 - starting new connection: https://readrust.net/
2024-02-22T18:26:31.602179031+08:00 - starting new connection: https://rustcc.cn/
2024-02-22T18:26:34.330849200+08:00 - RSS2
2024-02-22T18:26:34.340296660+08:00 - Atom
2024-02-22T18:26:34.350076762+08:00 - RSS2
2024-02-22T18:26:34.350163283+08:00 - 文章标题：【Rust比赛】vivo 蓝河操作系统创新赛火热报名中，75万奖金池等你来挑战！
2024-02-22T18:26:34.350193716+08:00 - 文章内容：<h2>活动介绍</h2>
<p>【vivo蓝河操作系统创新赛】是开放原子开源大赛下设的独立赛项，由vivo联合承办，包含“蓝河代码转译工具”、“蓝河创新应用开发”两大赛题。</p>
<p><a href="https://mp.weixin.qq.com/s/uMBX-zy_XH2iO9WfFLEBWQ" rel="noopener noreferrer">更多比赛信息请参考文章</a></p>
<h3>01 蓝河代码转译工具</h3>
<p>赛题说明：
参赛者需要设计并实现一个具有与蓝河系统/应用相关的代码转译能力的工具程序，完成与蓝河系统/应用相关的代码转译，从而加快操作系统关键技术的突破，从源头保障操作系统内存安全，促进操作系统底层技术发展，加速操作系统生态建设。</p>
<p><a href="https://competition.atomgit.com/competitionInfo?id=d8a588f9ef9b2d1686cc292c3b032f7b" rel="noopener noreferrer">报名入口&gt;&gt;</a></p>
<h3>02 蓝河创新应用开发</h3>
<p>赛题说明：
参赛者基于蓝河操作系统，通过学习蓝河应用开发标准，基于蓝河系统提供的开放能力和用户真实的使用场景，结合 AI 能力，开发出具有创新性的应用，繁荣蓝河生态。</p>
<p><a href="https://competition.atomgit.com/competitionInfo?id=c50d174fbf4d55a7172b25cb784258f8" rel="noopener noreferrer">报名入口&gt;&gt; </a></p>
<h4>注1：</h4>
<p>赛道1主要是C转译Rust的工具方面，非常适合所有 Rust 同学参与，尤其是对操作系统感兴趣的；赛道2主要是基于蓝河操作系统的开放API实现应用开发，且系统自带AI能力加持，几乎适合所有开发同学，非常类似于小程序那一套，从界面交互到数据和网络通信，很容易上手，且提供专用的IDE。</p>
<h4>注2：</h4>
<p>蓝河操作系统 BlueOS 系统架构介绍 <a href="https://blueos.vivo.com/" rel="noopener noreferrer">https://blueos.vivo.com/ </a></p>
<p>蓝河操作系统 BlueOS 开放能力、API、开发工具、教程与文档 <a href="https://developers.vivo.com/product/blueOpen/ability" rel="noopener noreferrer">https://developers.vivo.com/product/blueOpen/ability</a></p>
<h5>预祝各位参赛选手获得大奖！</h5>
2024-02-22T18:26:34.350220146+08:00 - 文章标题：有没有好用的crates发布工具
2024-02-22T18:26:34.350242316+08:00 - 文章内容：<p>现在一个工程下面有多个crates,而且有依赖关系，可不可以把release(包括发布到crates.io/编译各个平台的二进制/制作docker上传到docker hub/自动在github写release)流程实现一个github action,让其自动化，其中发布到crates.io的时候版本号的更新是一个非常繁琐的过程，稍微不小心就会出错，这块如果也能自动化就好了，各位如果有这方面经验的可以借鉴一下，在网上找了一些例子和工具：</p>
<p>工具，不知道好不好用：</p>
<p><a href="https://github.com/Byron/cargo-smart-release" rel="noopener noreferrer">https://github.com/Byron/cargo-smart-release
</a></p>
<p><a href="https://github.com/pksunkara/cargo-workspaces" rel="noopener noreferrer">https://github.com/pksunkara/cargo-workspaces</a></p>
<p>例子：
<a href="https://github.com/svenstaro/miniserve/blob/master/.github/workflows/build-release.yml" rel="noopener noreferrer">https://github.com/svenstaro/miniserve/blob/master/.github/workflows/build-release.yml</a></p>
<p>blog:</p>
<p><a href="https://blog.orhun.dev/automated-rust-releases/" rel="noopener noreferrer">https://blog.orhun.dev/automated-rust-releases/</a></p>
2024-02-22T18:26:34.350274374+08:00 - 文章标题：【Rust日报】2024-02-20 cve-rs 编写安全代码来让 Rust 不内存安全！
2024-02-22T18:26:34.350327216+08:00 - 文章内容：<h3>cve-rs 编写安全代码来让 Rust 不内存安全！</h3>
<p>cve-rs 允许你编写安全代码来在 Rust 程序中引入内存安全漏洞。给出的所有的例子都没有使用 <code>unsafe</code> 代码块。</p>
<p>cve-rs 主要实现了这三种安全问题：</p>
<ul>
<li>Use after free</li>
<li>Buffer overflow</li>
<li>Segmentation fault</li>
</ul>
<p>比如这是一个 UAF 的问题实例：</p>
<p><img src="https://raw.githubusercontent.com/Speykious/cve-rs/main/segfault-demo.png" alt="uaf"></p>
<p>ReadMore: <a href="https://github.com/Speykious/cve-rs/tree/main" rel="noopener noreferrer">https://github.com/Speykious/cve-rs/tree/main</a></p>
<h3>又一个 Rust 实现的命令行版贪吃蛇游戏</h3>
<pre><code>cargo install snakepipe

# basic usage
snakepipe gamestate|snakepipe render

# change the defaults
snakepipe gamestate --frame-duration 80 --width 70 --height 20 --snakepipe-length 15|snakepipe render

# call help on any of the commands
snakepipe --help
</code></pre>
<p>ReadMore: <a href="https://github.com/topheman/snake-pipe-rust" rel="noopener noreferrer">https://github.com/topheman/snake-pipe-rust</a></p>
<h3>使用 Rust 编写一个语言解释器</h3>
<p>目前已经更新了 6 篇文章了， 涵盖简介、词法分析、语法分析、类型表示、执行环境、执行I 等，对编译原理感兴趣的可以关注一下</p>
<p>ReadMore: <a href="https://buildingwithrust.substack.com/archive" rel="noopener noreferrer">https://buildingwithrust.substack.com/archive</a></p>
<hr>
<p>From 日报小组 Koalr</p>
<p>社区学习交流平台订阅：</p>
<ul>
<li><a href="https://rustcc.cn/" rel="noopener noreferrer">Rustcc论坛: 支持rss</a></li>
<li><a href="https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" rel="noopener noreferrer">微信公众号：Rust语言中文社区</a></li>
</ul>
2024-02-22T18:26:34.350358099+08:00 - 文章标题：Rust中的Fn、FnMut 和 FnOnce都有什么区别？
2024-02-22T18:26:34.350388888+08:00 - 文章内容：<p>在 Rust 中，Fn、FnMut 和 FnOnce 是三个用于表示闭包类型的 trait。闭包是一种可以捕获其环境变量的函数。在创建闭包是会默认实现这几个 trait 中的一个。
以下是三个 trait 的区别：</p>
<p>Fn：Fn 是最基本的闭包 trait。它表示闭包可以捕获其环境变量的不可变引用。</p>
<p>FnMut：FnMut 表示闭包可以捕获其环境变量的可变引用。这意味着闭包可以修改其环境变量的值。</p>
<p>FnOnce：FnOnce 表示闭包只能调用一次。它表示闭包可以捕获其环境变量的所有权。这意味着闭包可以移动其环境变量的值。</p>
<p>武汉/深圳，后端开发，专属内推通道</p>
2024-02-22T18:26:34.350417109+08:00 - 文章标题：请问有没原生的类似minhook的crate
2024-02-22T18:26:34.350445449+08:00 - 文章内容：<p>retour有hook函数，可是没发现有在某地址写jmp跳转到分配的内存的功能</p>
2024-02-22T18:26:34.350463996+08:00 - 文章标题：结构体包含另一个结构体引用时，serde序列化问题
2024-02-22T18:26:34.350494168+08:00 - 文章内容：<p>代码如下</p>
<pre><code>use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct Person {
    id: String,
    name: String,
}

#[derive(Serialize, Deserialize)]
struct Msg&lt;'a&gt; {
    id: String,
    person: &amp;'a Person,
}

fn main() {
    let person = Person {
        id: "123".to_string(),
        name: "Alice".to_string(),
    };

    let msg = Msg {
        id: "456".to_string(),
        person: &amp;person,
    };

    let msg_str = serde_json::to_string(&amp;msg).unwrap();
    println!("Serialized Msg: {}", msg_str);
}
</code></pre>
<p>报错如下</p>
<pre><code>error[E0277]: the trait bound `&amp;'a Person: Deserialize&lt;'_&gt;` is not satisfied
    --&gt; src/main.rs:2463:13
     |
2463 |     person: &amp;'a Person,
     |             ^^^^^^^^^^ the trait `Deserialize&lt;'_&gt;` is not implemented for `&amp;'a Person`
     |
note: required by a bound in `next_element`
    --&gt; /home/alxps/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.195/src/de/mod.rs:1726:12
     |
1724 |     fn next_element&lt;T&gt;(&amp;mut self) -&gt; Result&lt;Option&lt;T&gt;, Self::Error&gt;
     |        ------------ required by a bound in this associated function
1725 |     where
1726 |         T: Deserialize&lt;'de&gt;,
     |            ^^^^^^^^^^^^^^^^ required by this bound in `SeqAccess::next_element`
help: consider removing the leading `&amp;`-reference
     |
2463 -     person: &amp;'a Person,
2463 +     person: Person,
     |

</code></pre>
<p>我不想让msg有person所有权，也不想clone person，现在要自定义序列化实现trait，要怎么写？或者有没有其他方法</p>
2024-02-22T18:26:34.350515711+08:00 - 文章标题：krpc-rust v0.2.0 发布，兼容Dubbo协议支持服务注册与发现
2024-02-22T18:26:34.350569021+08:00 - 文章内容：<h1><code>krpc-rust</code> 一个最像RPC框架的Rust-RPC框架</h1>
<p>krpc-rust是一个高性能，轻量级的rpc框架，通过使用Rust宏来解决目前主流rpc框架使用复杂，性能低等问题，不需要通过脚本和脚手架生成rpc调用代码，通过宏来进行编译期"反射"来实现高性能的调用，来满足rpc调用的简易性，同时支持Dubbo3服务的注册发现和互相调用;</p>
<h2>快速开始</h2>
<h3>Server</h3>
<pre><code>#[derive(Serialize, Deserialize, Default, Debug)]
struct ReqDto {
    name: String,
}

#[derive(Serialize, Deserialize, Default, Debug)]
struct ResDto {
    res: String,
}

#[derive(Clone)]
struct DemoService {
    _db: String,
}

krpc_server! {
   //设置包路径
   "org.apache.dubbo.springboot.demo",
   //设置service-name
   DemoService,
   //设置service-versions
   None,
   async fn sayHello(&amp;self,req : String) -&gt; Result&lt;String&gt; {
      info!("res : {:?}" ,req);
      return Ok("Hello ".to_owned() + &amp;req);
   }
   async fn sayHelloV2(&amp;self,req : ReqDto) -&gt; Result&lt;ResDto&gt; {
      info!("res : {:?}" ,req);
      return Ok(ResDto{res :  "Hello ".to_owned() + &amp;req.name + " V2"});
   }
}

#[tokio::main(worker_threads = 512)]
async fn main() {
    krpc_common::init_log();
    let server: DemoService = DemoService {
        _db: "我是一个DB数据库".to_string(),
    };
    KrpcServer::build(
        //配置注册中心
        RegisterBuilder::new(
            &amp;format!("127.0.0.1:{}", "2181"),
            "default",
            RegisterType::ZooKeeper,
        ),
        //设置监听端口
        "8081",
    )
    .add_rpc_server(Box::new(server))
    .run()
    .await;
}

</code></pre>
<h3>Client</h3>
<pre><code>//初始化KrpcClient
lazy_static! {
    static ref CLI: KrpcClient = KrpcClient::build(
        //配置注册中心
        RegisterBuilder::new(
            &amp;format!("127.0.0.1:{}", "2181"),
            "default",
            RegisterType::ZooKeeper,
        )
    );
}

#[derive(Serialize, Deserialize, Default, Debug)]
struct ReqDto {
    name: String,
}

#[derive(Serialize, Deserialize, Default, Debug)]
struct ResDto {
    res : String,
}

struct DemoService;
//声明Rpc接口
krpc_client! {
   CLI,
   //设置API包路径
   "org.apache.dubbo.springboot.demo",
   //设置service-name
   DemoService,
   //设置service-versions
   None,
   async fn sayHello(&amp;self,req : String) -&gt; Result&lt;String&gt;
   async fn sayHelloV2(&amp;self,req : ReqDto) -&gt; Result&lt;ResDto&gt;
} 

#[tokio::main(worker_threads = 512)]
async fn main() {
    krpc_common::init_log();
    let client = DemoService;
    let res = client.sayHello("world".to_string()).await;
    info!("{:?}",res);
    let res = client.sayHelloV2(ReqDto{name:"world".to_string()}).await;
    info!("{:?}",res);
}
</code></pre>
<h3>Dubbo3</h3>
<p>本项目同时兼容dubbo3协议，可以很方便的与Java版本的Dubbo3项目通过接口暴露的方式进行服务注册发现和互调。</p>
<p>Rust的Server和Client完全不用改造就如上示例即可。</p>
<p>Java版本的Dubbo3项目，代码层面不需要改造，只需要添加一些依赖和配置（因Dubbo3使用接口暴露的方式默认不支持json序列化协议，而是采用fastjson2的二进制序列化格式，所以这里我们需手动添加fastjson1的支持）</p>
<p>这里我们使用duboo3的官方示例dubbo-samples-spring-boot项目进行演示
https://github.com/apache/dubbo-samples</p>
<p>首先我们需要把Server和Client的服务的pom.xml都添加fastjson1的maven依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
    &lt;artifactId&gt;dubbo-serialization-fastjson&lt;/artifactId&gt;
    &lt;version&gt;2.7.23&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3>Java-Server</h3>
<pre><code>@DubboService
public class DemoServiceImpl implements DemoService {

    @Override
    public String sayHello(String name) {
        return "Hello " + name;
    }
}
</code></pre>
<h3>Server-application.yml</h3>
<pre><code>dubbo:
  application:
    name: dubbo-springboot-demo-provider
  protocol:
    name: tri
    port: 50052
    //添加fastjson的支持
    prefer-serialization: fastjson
  registry:
    address: zookeeper://${zookeeper.address:127.0.0.1}:2181
</code></pre>
<h3>Java-Client</h3>
<pre><code>@Component
public class Task implements CommandLineRunner {
    @DubboReference
    private DemoService demoService;

    @Override
    public void run(String... args) throws Exception {
        String result = demoService.sayHello("world");
        System.out.println("Receive result ======&gt; " + result);

        new Thread(()-&gt; {
            while (true) {
                try {
                    Thread.sleep(1000);
                    System.out.println(new Date() + " Receive result ======&gt; " + demoService.sayHello("world"));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    Thread.currentThread().interrupt();
                }
            }
        }).start();
    }
}
</code></pre>
<h3>Client-application.yml</h3>
<pre><code>dubbo:
  application:
    name: dubbo-springboot-demo-consumer
  registry:
    address: zookeeper://${zookeeper.address:127.0.0.1}:2181
</code></pre>
2024-02-22T18:26:34.350616266+08:00 - 文章标题：【Rust日报】2024-02-19 Linux 内核准备升级至 Rust 1.77
2024-02-22T18:26:34.350651214+08:00 - 文章内容：<h1>Linux 内核准备升级至 Rust 1.77</h1>
<p>Linux 6.8 内核已经升级至 Rust 1.75，而最新的补丁则将内核的 Rust 代码迁移到 Rust 1.76，并准备好迎接即将发布的 Rust 1.77。
Rust 1.77 稳定了内核 Rust 代码使用的单字段 "offset_of" 功能，并添加了一个"--check-cfg" 选项，内核 Rust 代码未来可能会过渡到这个选项。这符合 Rust for Linux 跟踪上游 Rust 版本升级的政策，直到确定了所有使用的功能都被认为是稳定的最低版本为止。预计将在即将到来的 Linux 6.9 内核合并窗口中进行对 Rust 1.77 的升级。</p>
<p><a href="https://www.phoronix.com/news/Linux-Kernel-To-Rust-1.77" rel="noopener noreferrer">原文链接</a></p>
<h1>极小的 Rust 二进制文件</h1>
<p>本文探索如何制作一个极小的 x86_64 Linux Rust 二进制文件，并比较其与纯汇编程序的竞争性。</p>
<p>从一个大小为 <code>3.6 MiB</code> 的起点开始，通过优化和调整，逐步减小二进制文件的大小。优化手段包括去除符号、调整编译参数、替换标准库等。通过去除标准库并直接使用 libc，以及自定义 _start 函数，极大地减小了二进制文件的大小。最终通过调整链接器标志和移除不必要的 ELF sections，将二进制文件的大小降至 <code>400 bytes</code>，达到了极小化的目标。</p>
<p>Rust 展现出了出色的系统编程能力，即使在 no_std 环境下也能进行嵌入式编程和其他应用领域。Rust 在性能和体积上的优势使其在实际应用中具有广泛的潜力，甚至可以取代一些汇编编写的程序。</p>
<p><a href="https://darkcoding.net/software/a-very-small-rust-binary-indeed/" rel="noopener noreferrer">原文链接</a></p>
<h1><code>FuturesUnordered</code> 以及 future的顺序</h1>
<p><strong>FuturesUnordered</strong> 是 Rust 中用于并发子任务的强大工具，但如果使用不当，会导致死锁。</p>
<h3>两种常见的 FuturesUnordered 使用模式：</h3>
<ul>
<li><strong>缓冲流</strong>：将工作流表示为 futures 的流，并使用类似 <code>buffered</code> 适配器将其缓冲。</li>
<li><strong>范围任务</strong>：将工作表示为“在” FuturesUnordered 上“生成”的任务，使用类似 <code>moro</code> 库的 API。</li>
</ul>
<h3>死锁的条件：</h3>
<ul>
<li><strong>互斥</strong>：每个任务都需要独占资源。</li>
<li><strong>等待资源</strong>：任务在等待其他资源时持有已分配的资源。</li>
<li><strong>不可抢占</strong>：资源不能从持有者手中强制移除。</li>
<li><strong>循环等待</strong>：存在任务链，每个任务都请求链中下一个任务持有的资源。</li>
</ul>
<h3>示例死锁：</h3>
<p>使用异步生成器和互斥锁。</p>
<pre><code>async gen {
    let mut guard = mutex.lock().await;
    yield x;
    yield y;
    drop(guard);
};

for await elem in iter {
    let mut guard = mutex.lock().await;
    println!("{}", elem);
    drop(guard);
}
</code></pre>
<h3>预防死锁：</h3>
<ul>
<li>通过显式声明并发性来避免控制流中的隐式共享资源。</li>
<li>优先使用范围任务而不是缓冲流，因为它们使资源依赖关系更清晰。</li>
<li>使用通道时要注意队列大小和循环依赖关系。</li>
<li>使用未缓冲通道测试以捕获潜在死锁。</li>
</ul>
<h3>Rust 的优势：</h3>
<ul>
<li>所有权和借用可以防止死锁和复杂的同步。</li>
<li>范围任务应该集成到运行时中以获得更好的借用支持。</li>
</ul>
<h3>其他注意事项：</h3>
<ul>
<li>文章批评了使用大量任意值作为通道大小的做法，因为它隐藏了潜在的死锁。</li>
<li>它建议使用利用所有权和借用的模式。</li>
</ul>
<h2>总结</h2>
<p>FuturesUnordered 是一个强大的工具，但需要谨慎使用以避免死锁。了解死锁的条件以及如何预防它们，并选择合适的模式来实现并发。Rust 的所有权和借用系统可以帮助防止死锁，并使代码更安全、更可靠。</p>
<p><a href="https://without.boats/blog/futures-unordered/" rel="noopener noreferrer">原文链接</a></p>
<h1>Inlyne: 无浏览器 markdown 预览工具</h1>
<p>Inlyne 是一款利用 GPU 加速的无浏览器工具，帮助您快速查看 Markdown 文件. 目前 0.4 版本发布.</p>
<p><img src="https://raw.githubusercontent.com/trimental/inlyne/v0.4/assets/img/example.png" alt="img"></p>
<p><a href="https://github.com/trimental/inlyne/releases/tag/v0.4.0" rel="noopener noreferrer">原文链接</a></p>
<p>--</p>
<p>From 日报小组 BobQ, FBI小白</p>
<p>社区学习交流平台订阅：</p>
<ul>
<li><a href="https://rustcc.cn/" rel="noopener noreferrer">Rustcc论坛: 支持rss</a></li>
<li><a href="https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" rel="noopener noreferrer">微信公众号：Rust语言中文社区</a></li>
</ul>
2024-02-22T18:26:34.350677632+08:00 - 文章标题：报名倒计时！首期自动驾驶OS开发中阶训练营
2024-02-22T18:26:34.350712345+08:00 - 文章内容：<p>国家智能网联汽车创新中心2024首期中阶训练营开始报名啦！</p>
<p>训练营是国家智能网联汽车创新中心发起的技术培训项目，旨在为在校大学生和智能汽车领域工作人员提供专业的自动驾驶操作系统开发技能和知识。培训课程涵盖三个阶段，初阶实现驱动开发，中阶完成OS移植适配，终阶面向自动驾驶场景应用。</p>
<p>本次中阶训练营历时约8周，涵盖了操作系统原理、目标硬件平台、内核移植、系统调优、项目实战等内容，优秀学员更有机会入职国家智能网联汽车创新中心及其合作单位。训练营全程开源免费。</p>
<p>欢迎感兴趣的朋友访问如下网址了解详情并参加报名！
https://mp.weixin.qq.com/s/QA7Z6i7Ax5dN9hrvZDi4nA</p>
2024-02-22T18:26:34.350740361+08:00 - 文章标题：Ferroc：一个无锁、可移植的堆内存分配器
2024-02-22T18:26:34.350814994+08:00 - 文章内容：<p>Ferroc（由“ferrum”和“malloc”组合而成）是一个用Rust编写的无锁、可移植的堆内存分配器，主要参考了<a href="https://github.com/microsoft/mimalloc" rel="noopener noreferrer">mimalloc</a>。</p>
<p>这个内存分配器的设计目标是性能打平目前各种主流的内存分配器（如mimalloc，tcmalloc等），同时提供多种多样的自定义配置以移植到各种环境，比如裸机、嵌入式平台等。</p>
<p>目前已经在crates.io上发布。</p>
<h2>示例</h2>
<p>最简单的用途是作为全局内存分配器：</p>
<pre><code>use ferroc::Ferroc;

#[global_allocator]
static FERROC: Ferroc = Ferroc;

fn main() {
    // Using the global allocator API.
    let _vec = vec![10; 100];

    // Manually allocate memory.
    let layout = std::alloc::Layout::new::&lt;u8&gt;();
    let ptr = Ferroc.allocate(layout).unwrap();
    unsafe { Ferroc.deallocate(ptr, layout) };

    // Immediately run some delayed clean-up operations.
    Ferroc.collect(/* force */false);
}
</code></pre>
<p>如果想要一些自定义配置，比如从mmap系统调用获取新内存还是仅分配静态内存，则可以使用<code>config!</code>系列宏：</p>
<pre><code>// This is the capacity of the necessary additional static
// memory space used by ferroc as the metadata storage.
const HEADER_CAP: usize = 4096;
ferroc::config!(pub Custom =&gt; ferroc::base::Static::&lt;HEADER_CAP&gt;);

#[global_allocator]
static CUSTOM: Custom = Custom;

// Multiple manageable static memory chunks can be loaded at runtime.
let chunk = unsafe { Chunk::from_static(/* ... */) };
CUSTOM.manage(chunk);

// ...And you can start allocation.
let _vec = vec![10; 100];
</code></pre>
<p><code>config!</code>系列宏配置出的分配器默认是带着TLS变量的。如果条件不允许，或者想要更多的自定义空间，可以直接使用内部的结构体（<code>Arenas</code>、<code>Context</code>、<code>Heap</code>）：</p>
<pre><code>ferroc = {version = "*", default-features = false, features = ["base-mmap"]}
</code></pre>
<pre><code>#![feature(allocator_api)]
use ferroc::{
    arena::Arenas,
    heap::{Heap, Context},
    base::Mmap,
};

fn main() {
    let arenas = Arenas::new(Mmap); // `Arenas` are `Send` &amp; `Sync`...
    let cx = Context::new(&amp;arenas);
    let heap = Heap::new(&amp;cx); // ...while `Context`s and `Heap`s are not.

    // Using the allocator API.
    let mut vec = Vec::new_in(&amp;heap);
    vec.extend([1, 2, 3, 4]);
    assert_eq!(vec.iter().sum::&lt;i32&gt;(), 10);

    // Manually allocate memory.
    let layout = std::alloc::Layout::new::&lt;u8&gt;();
    let ptr = heap.allocate(layout).unwrap();
    unsafe { heap.deallocate(ptr, layout) };

    // Immediately run some delayed clean-up operations.
    heap.collect(/* force */false);
}
</code></pre>
<h2>Cargo功能列表</h2>
<ul>
<li>基本功能包含公开的结构体<code>Arenas</code>, <code>Context</code>和<code>Heap</code>；</li>
<li><code>"stat"</code>：统计内存分配数据；</li>
<li><code>"base-static"</code>：默认的静态内存基础分配器<code>Static</code>;</li>
<li><code>"base-mmap"</code>：使用OS自带的虚拟内存系列函数来获取新内存的基础分配器<code>Mmap</code>（依赖<code>std</code>）；</li>
<li><code>"global"</code>：<code>config!</code>和<code>config_mod!</code>等配置宏（自带的TLS变量默认会被泄露）；</li>
<li><code>"libc"</code>: <code>libc</code>依赖项（被<code>config!</code>系列宏的<code>pthread</code>选项依赖，目的是使用pthread的TLS变量析构器来析构<code>config!</code>生成的TLS变量）；</li>
<li><code>"default"</code>：默认的<code>Ferroc</code>分配器，基于<code>Mmap</code>和<code>pthread</code>选项（包括以上所有feature）；</li>
<li><code>"c"</code>：生成<code>fe_malloc</code>等C系列函数和一个C/C++头文件<code>"ferroc.h"</code>，并且如果编译时指定了<code>--cfg sys_alloc</code>会替换掉默认的<code>malloc</code>系列函数；</li>
<li><code>"track-valgrind"</code>：基于<a href="https://github.com/2dav/crabgrind" rel="noopener noreferrer"><code>crabgrind</code></a>的Valgrind内存跟踪检查器.</li>
</ul>
<h2>基准测试</h2>
<p>基准测试使用<a href="https://github.com/daanx/mimalloc-bench" rel="noopener noreferrer"><code>mimalloc-bench</code></a>的一部分子集。在我的16GB内存和Intel i7-10750H CPU @ 2.60GHz处理器的笔记本电脑上运行。</p>
<p>花费时间：
<img src="https://github.com/js2xxx/ferroc/blob/master/assets/time.png?raw=true" alt="Time consumed"></p>
<p>内存占用：
<img src="https://github.com/js2xxx/ferroc/blob/master/assets/memory.png?raw=true" alt="Memory consumed"></p>
<h2>缺点</h2>
<p>目前仅支持最新的Nightly通道的Rust编译器，并且<code>malloc-bench</code>中其他的一部分测试还尚未跑通。</p>
<h3>许可证</h3>
<p>MIT OR Apache-2.0</p>
2024-02-22T18:26:34.350861320+08:00 - 文章标题：Lightning Network Development Recruitment
2024-02-22T18:26:34.350880623+08:00 - 文章内容：<p>responsibilities</p>
<p>As an Open Source RGB/Lightning Developer, you will be a part of the team that contributes to the development of the RGB protocol for assets on top of Bitcoin and the Lightning Network, aimed at building a new ecosystem of Bitcoin based decentralized financial applications. This includes:</p>
<ul>
<li>Contributing to improve and evolve the code functional to the RGB protocol.</li>
<li>Development and maintenance of libraries to facilitate RGB integration for wallet developers.</li>
<li>Development and maintenance of an RGB compatible Bitcoin wallet.</li>
<li>Development and maintenance of Lightning Network and DEX compatible applications.
requirements</li>
<li>Knowledgeable about Bitcoin, Lightning Network and related applications.</li>
<li>Knowledgeable about Rust, Docker and Linux
Work experience: Rust &gt; 2 years, able to provide personal github address.</li>
</ul>
<p>Salary：4000-7000USD/month
Telegram:@C89043</p>
2024-02-22T18:26:34.350888102+08:00 - 文章标题：Rust登陆【华为鸿蒙】操作系统之Native模块开发
2024-02-22T18:26:34.351737990+08:00 - 文章内容：<h1><code>Rust</code>登陆【华为鸿蒙】操作系统之<code>Native</code>模块开发</h1>
<h2>名词解释</h2>
<ul>
<li>【鸿蒙操作系统】的英文全名是<code>Open Harmony Operation System</code>。正文将以其首字母缩写词<code>ohos</code>引用该词条。</li>
<li>【鸿蒙软件开发工具包】的英文全名是<code>Open Harmony Software Development Kit</code>。正文也将以它的首字母缩写词<code>ohsdk</code>引用该词条。</li>
<li><code>DevEco Studio IDE</code>是【华为】为鸿蒙应用程序开发免费提供的集成开发环境。它的最新稳定版内置了<code>ohsdk 3.1.0 (API v9)</code>。</li>
<li>【<code>Native</code>模块】是指由遵循了<code>ArkTs NAPI</code>接口规范的<code>C/Cpp/Rust</code>程序经交叉编译输出的链接库<code>.so</code>文件。</li>
</ul>
<h2>前言</h2>
<p>到写文章时止，虽然华为技术团队既未将<code>rustup</code>工具链无缝集成入<code>DevEco Studio IDE</code>也未提供<code>ArkTs + Rust</code>的“一站式”混合编程体验，但<code>Rust</code>登陆<code>ohos</code>依旧势不可挡，因为相较于<code>Rust</code>带来的生产效率收益（参照<code>c / cpp</code>），搭建交叉编译环境的人工成本真的微不足道。甚至，求助于【操作系统镜像】或<code>Docker</code>技术，@Rustacean 还能避免这类重复性劳动的再次发生。</p>
<p>为了填补<code>DevEco Studio IDE</code>与<code>rustup</code>工具链之间的“窄沟”，仅有两步操作需被执行：</p>
<ol>
<li>搭建面向<code>ohos</code>的交叉编译环境。
<ul>
<li>限于作者<code>dev box</code>是<code>Windows 11</code>，所以本篇文章仅分享从<code>Windows</code>至<code>ohos</code>的交叉编译环境搭建心得。</li>
</ul>
</li>
<li>将交叉编译输出的<code>.so</code>文件注入<code>DevEco Studio</code>工作流。</li>
</ol>
<h2>搭建<code>Windows</code>  ➞ <code>ohos</code>交叉编译环境</h2>
<p>鉴于华为硬件产品的三款主流<code>CPU</code>架构，@Rustacean 需同时准备三套交叉编译方案，分别是：</p>
<ul>
<li>面向<code>64</code>位<code>ARM CPU</code>的<code>aarch64-unknown-linux-ohos</code>方案。</li>
<li>面向<code>32</code>位<code>ARM CPU</code>的<code>armv7-unknown-linux-ohos</code>方案。</li>
<li>面向<code>64</code>位<code>AMD / Intel CPU</code>的<code>x86_64-unknown-linux-ohos</code>方案。</li>
</ul>
<p>前两套方案是为【真机】设备提供动态链接库/<code>Native</code>模块；而后一套方案则是服务于手机模拟器（虚拟机）的。</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/5efb6ea0-5f89-42d1-8654-bf9ee712e84e" alt="image"></p>
<p>上表中<code>Triple</code>的信息描述格式统一是：</p>
<pre><code>&lt;CPU架构&gt;&lt;CPU子架构&gt;-&lt;厂商&gt;-&lt;操作系统&gt;-&lt;应用程序二进制接口格式&gt;
</code></pre>
<p>于是，<code>armv7-unknown-linux-ohos</code>应被读作</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/accaeb68-59f6-4409-90f4-a6826250fdfe" alt="image"></p>
<p>【厂商】栏的<code>unkown</code>是<code>Mozilla</code>公司的“锅”，而不是我定的。就我本意，这一栏馁馁的是汉语拼音<code>HuaWei</code>。</p>
<p>下面上干货了...</p>
<h3>第一步，给<code>ohsdk</code>补装<code>native</code>组件</h3>
<p><code>DevEco Studio IDE</code>的内置<code>ohsdk</code>位于<code>%LocalAppData%\Huawei\Sdk\openharmony\&lt;API 版本号&gt;</code>目录下，但其初始安装却缺失了<code>native</code>组件（— 可能是因为这个模块太大了，超过<code>2GB</code>）。所以，@Rustacean 需要</p>
<ol>
<li>补装<code>native</code>组件</li>
<li>记住<code>ohsdk</code>对应的【<code>API</code>版本号】，因为后续配置得用。</li>
</ol>
<h4>具体步骤</h4>
<ol>
<li>
<p>打开<code>DevEco Studio IDE</code></p>
</li>
<li>
<p>若出现的是【欢迎界面】，就从菜单<code>Configure</code> ➞ <code>Settings</code>，打开<code>Settings</code>对话框</p>
</li>
<li>
<p>若出现的是【工程界面】，就从菜单<code>File</code> ➞ <code>Settings</code>，打开<code>Settings</code>对话框</p>
</li>
<li>
<p>从对话框左侧选择<code>SDK</code>；从右侧查看<code>Platform</code>选项卡下面的内容</p>
</li>
<li>
<p>寻找并记忆被勾选的【<code>SDK</code>版本号 (<code>API</code>版本号)】。比如，下图中的<code>3.1.0 (API 9)</code>。</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/97a34762-1dd0-49d2-b7bf-3b3ee4179611" alt="image"></p>
</li>
<li>
<p>勾选<code>native</code>复选框</p>
</li>
<li>
<p>点击<code>OK</code>按钮</p>
</li>
<li>
<p>等待<code>native</code>组件安装完成 — 耐心点儿，等待时间可不短</p>
</li>
</ol>
<p>待上述操作都正常完成之后，便可见如下所示的新目录结构</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/e7cb9374-fb99-4302-87ef-5dcc37764226" alt="image"></p>
<h3>第二步，重新编译<code>Rust</code>标准库</h3>
<p>之所以把事情搞这么大是因为<code>Mozilla</code>厂方并没有为<code>ohos</code>提供<strong>预编译</strong>的【标准库】二进制文件。于是，尽管<code>ohos</code>已被纳入了<code>rustc</code>交叉编译支持清单（请见下图）</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/b9759f8e-74ed-4c01-816d-18b1485123b5" alt="image"></p>
<p>，但直接执行交叉编译指令</p>
<pre><code>cargo build --release --target=aarch64-unknown-linux-ohos
</code></pre>
<p>还是会遭遇失败和看到<code>E0463</code>号错误</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/46f21f43-13f0-40de-85f5-b562e27c5fc7" alt="image"></p>
<h4>技术方案选型</h4>
<p>编译【标准库】源码有两条技术路径</p>
<ol>
<li>
<p>重新编译整条<code>rustup</code>工具链，捎带着也就编译出【标准库】了 — 难！我没搞定</p>
</li>
<li>
<p>将【标准库】作为<strong>普通</strong>依赖<code>crate</code>和<code>Cargo (Lib) Package</code>工程的业务代码一起编译（— 注：这个解释并不精确，因为细究起来<strong>主</strong><code>crate</code>与<strong>依赖</strong><code>crates</code>是搅和在一起的各自独立编译，而不是绝对意义上的“一锅烩”）。下图中被红框圈定的<code>crates</code>就都出自于【标准库】</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/88cfafee-2836-40b4-a82b-c566a174cb84" alt="image"></p>
</li>
</ol>
<p>我选择了<strong>第二条</strong>技术路线。虽然后一条技术路线拖长了程序编译的总用时，但它仅会影响<strong>首次</strong>编译操作。从那以后，借助<a href="https://github.com/mozilla/sccache?tab=readme-ov-file#sccache---shared-compilation-cache" rel="noopener noreferrer">sccache</a>编译缓存技术，由【标准库】引入的额外延时几乎可以忽略不计。更重要的是，该技术路线不会阻塞 @Rustacean 对<code>rustup</code>工具链的后续升级。咱们随时都可以<code>rustup update</code>。</p>
<h4>采用【方案二】的准备工作与先决条件</h4>
<ol>
<li>
<p>给<code>rustup</code>工具链，补装【标准库】源码（即，<code>rust-src</code>组件）。</p>
<p>从命令行，立即执行且仅执行一次：</p>
<pre><code>rustup component add rust-src
</code></pre>
</li>
<li>
<p>启用<code>nigtly</code>工具链，因为工具链的<code>stable</code>版本还尚不支持“裹挟【标准库】共同编译”的新功能。</p>
<p>从命令行，立即执行且仅执行一次：</p>
<pre><code>rustup default nightly
</code></pre>
</li>
<li>
<p>采用<code>ohsdk</code>内置的<code>llvm - clang</code>作为<code>rustc</code>链接器（下一节将详细介绍）</p>
</li>
<li>
<p>向交叉编译指令添加新命令行参数<code>-Zbuild-std</code>。</p>
<ol>
<li>
<p><code>cargo</code>会透传该参数给<code>rustc</code>并指示编译器不是寻找现成的【标准库】链接文件而是<strong>现场</strong>编译【标准库】源码。</p>
</li>
<li>
<p>编译指令也将变为</p>
<pre><code>cargo +nightly build -Zbuild-std --release --target=aarch64-unknown-linux-ohos
</code></pre>
</li>
</ol>
</li>
</ol>
<h4>如何把<code>ohsdk</code>内置的<code>llvm - clang</code>作为<code>rustc</code>链接器</h4>
<p><strong>第一步</strong>，回忆之前记下的【鸿蒙<code>API</code>版本号】数字和新建环境变量<code>OHOS_API_V</code>。【推荐】从<code>Cargo</code>全局配置文件<code>%UserProfile%\.cargo\config.toml</code>新建<code>OHOS_API_V</code>环境变量，因为</p>
<ul>
<li>一方面，这可最小化对系统环境的“污染” — 该变量仅对<code>Rust</code>交叉编译有用，没有必要系统级全局可见。</li>
<li>另一方面，它随时可被【会话级】<strong>同名</strong>环境变量短暂复写，方便以后临时变更做试验。</li>
</ul>
<p>打开<code>%UserProfile%\.cargo\config.toml</code>配置文件和添加配置表</p>
<pre><code>[env]
OHOS_API_V = "9"
</code></pre>
<p>【注意】伴随今后<code>ohsdk</code>的<strong>自动</strong>升级，该环境变量的值须被同步地<strong>手动</strong>更新，以避免编译失败。</p>
<p><strong>第二步</strong>，将<code>ohsdk</code>目录下的<code>LLVM</code>前端编译器<code>llvm\bin\clang.exe</code>包装为<code>rustc</code>的【<strong>鸿蒙</strong>链接器】。敲黑板，重点来了！@Rustacean 需分别构建<strong>三个</strong>链接器，以服务<strong>三套</strong>交叉编译方案，和向华为的<strong>三类</strong>硬件设备提供<code>.so</code>文件。于是，有</p>
<ul>
<li>
<p>【链接器1】面向<code>64</code>位<code>ARM CPU</code><strong>真机</strong>的<code>aarch64-unknown-linux-ohos</code>交叉编译方案。在<code>%UserProfile%</code>目录下，新建<code>cmd</code>文件<code>aarch64-unknown-linux-ohos-clang.cmd</code>，并添加如下代码</p>
<pre><code>%LocalAppData%\Huawei\Sdk\openharmony\%OHOS_API_V%\native\llvm\bin\clang.exe ^
-target aarch64-linux-ohos ^
--sysroot=%LocalAppData%\Huawei\Sdk\openharmony\%OHOS_API_V%\native\sysroot ^
-D__MUSL__ %*
</code></pre>
</li>
<li>
<p>【链接器2】面向<code>32</code>位<code>ARM CPU</code><strong>真机</strong>的<code>armv7-unknown-linux-ohos</code>交叉编译方案。在<code>%UserProfile%</code>目录下，新建<code>cmd</code>文件<code>armv7-unknown-linux-ohos-clang.cmd</code>，并添加如下代码</p>
<pre><code>%LocalAppData%\Huawei\Sdk\openharmony\%OHOS_API_V%\native\llvm\bin\clang.exe ^
-target arm-linux-ohos ^
--sysroot=%LocalAppData%\Huawei\Sdk\openharmony\%OHOS_API_V%\native\sysroot ^
-D__MUSL__ ^
-march=armv7-a ^
-mfloat-abi=softfp ^
-mtune=generic-armv7-a ^
-mthumb %*
</code></pre>
</li>
<li>
<p>【链接器3】面向<code>64</code>位<code>AMD / Intel CPU</code><strong>模拟器</strong>的<code>x86_64-unknown-linux-ohos</code>交叉编译方案。在<code>%UserProfile%</code>目录下，新建<code>cmd</code>文件<code>x86_64-unknown-linux-ohos-clang.cmd</code>，并添加如下代码</p>
<pre><code>%LocalAppData%\Huawei\Sdk\openharmony\%OHOS_API_V%\native\llvm\bin\clang.exe ^
-target x86_64-linux-ohos ^
--sysroot=%LocalAppData%\Huawei\Sdk\openharmony\%OHOS_API_V%\native\sysroot ^
-D__MUSL__ %*
</code></pre>
</li>
</ul>
<p><strong>第三步</strong>，全局且有条件地向<code>rustc</code>装配【鸿蒙链接器】。其中，</p>
<ul>
<li>【全局】意味着修改<code>Cargo</code>全局配置文件<code>%UserProfile%\.cargo\config.toml</code>和作用于所有<code>Cargo Package</code>工程。</li>
<li>【有条件】意味着采用<strong>条件编译</strong>语法<code>target.&lt;triple&gt;.linker</code>限定该【链接器】仅生效于面向<code>ohos</code>的交叉编译操作。</li>
</ul>
<p>具体作法，打开<code>%UserProfile%\.cargo\config.toml</code>配置文件和添加配置表</p>
<pre><code>[target.aarch64-unknown-linux-ohos]
linker = "./aarch64-unknown-linux-ohos-clang.cmd"
[target.armv7-unknown-linux-ohos]
linker = "./armv7-unknown-linux-ohos-clang.cmd"
[target.x86_64-unknown-linux-ohos]
linker = "./x86_64-unknown-linux-ohos-clang.cmd"
[profile.dev.package.compiler_builtins]
opt-level = 2
</code></pre>
<p>再对前面配置片段补充两点解释：</p>
<ol>
<li>配置项<code>linker</code>以<strong>相对</strong>路径引用链接器文件的背后逻辑是<code>cargo</code>总是以<code>config.toml</code>的<strong>父文件夹</strong>（.cargo）<strong>所处目录</strong>为起点开始解析<strong>相对</strong>路径（，而不是以<code>config.toml</code>的同级目录为起点）。所以，本例中的<code>./</code>路径前缀对应的就是登录账号的根目录<code>%UserProfile%</code>。</li>
<li>配置项<code>opt-level</code>，借助【<code>Profile</code>重写（i.e. Override）】配置表头<code>[profile.dev.package.compiler_builtins]</code>，仅将【开发编译】模式下【标准库】内<code>compiler_builtins crate</code>的代码优化级别强制锚定于<code>2</code>。否则，<code>cargo build -Zbuild-std --target=aarch64-unknown-linux-ohos</code>指令（注意：没有<code>--release</code>参数）会概率性地失败于<code>exit code: 0xc0000005, STATUS_ACCESS_VIOLATION</code>错误。</li>
</ol>
<p><strong>第四步</strong>，给冗长的交叉编译指令约定（短）别名。</p>
<p>还是打开<code>%UserProfile%\.cargo\config.toml</code>配置文件和增补如下配置表</p>
<pre><code>[alias]
ohos-build = ["build", "-Zbuild-std", "--target=aarch64-unknown-linux-ohos", "--target=armv7-unknown-linux-ohos", "--target=x86_64-unknown-linux-ohos"]
</code></pre>
<p>于是，只要执行<strong>一条</strong><code>cargo ohos-build</code>指令就相当于连续执行下面<strong>三条</strong>编译指令：</p>
<ol>
<li><code>cargo build -Zbuild-std --target=aarch64-unknown-linux-ohos</code></li>
<li><code>cargo build -Zbuild-std --target=armv7-unknown-linux-ohos</code></li>
<li><code>cargo build -Zbuild-std --target=x86_64-unknown-linux-ohos</code></li>
</ol>
<h3>总结交叉编译环境的搭建成果</h3>
<p>以后每次在<code>Cargo (Lib) Package</code>工程根目录下执行</p>
<pre><code>cargo ohos-build --release
</code></pre>
<p>，编译器都会立即</p>
<ol>
<li>唤起<code>ohsdk</code>内置的<code>LLVM</code>前端编译器<code>llvm - clang</code>作为<code>rustc</code>链接器</li>
<li>将【标准库】源码作为<strong>普通</strong>依赖<code>crate</code>与<strong>主</strong><code>crate</code>业务程序一起编译</li>
<li>并行启动三个<code>JOB</code>进程对同一套<code>Rust</code>源码同时执行三组交叉编译操作</li>
<li>交叉编译输出三个<strong>文件名相同</strong>但 <strong><code>ABI</code>格式不同</strong>的动态链接库<code>.so</code>文件</li>
</ol>
<h3>新建<code>Cargo (Library) Package</code>工程，验证交叉编译环境</h3>
<p>首先，克隆<a href="https://github.com/stuartZhang/socket2" rel="noopener noreferrer">stuartZhang/socket2</a>至本地，并将代码分支切至<code>v0.4.x</code>。</p>
<pre><code>git clone git@github.com:stuartZhang/socket2.git
cd socket2
git checkout -q v0.4.x
</code></pre>
<p>关于这一步操作的必要性，我已经详细地阐述于<a href="https://github.com/stuartZhang/node-bindgen?tab=readme-ov-file#ohos-node-bindgen%E8%BF%98%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8" rel="noopener noreferrer">ohos-node-bindgen还不能被直接使用</a>章节了。简单地讲，这是为了绕过<a href="https://crates.io/crates/socket2" rel="noopener noreferrer">socket2 crate</a>对华为鸿蒙操作系统的<strong>不兼容</strong>缺陷。</p>
<p>然后，从命令行，新建<code>Cargo (Library) Package</code>工程</p>
<pre><code>cd ..
cargo new --lib calculator
code calculator
</code></pre>
<p>其次，在<code>VSCode</code>内，打开<code>Cargo.toml</code>文件，和追加如下内容</p>
<pre><code>[lib]
crate-type = ["cdylib"]

[dependencies]
ohos-node-bindgen = "6.0.3"
socket2 = "0.4.10"

[patch.crates-io]
socket2 = { path = "../socket2" }
</code></pre>
<p>前面配置片段内的【依赖图重写】配置表<code>[patch.crates-io]</code>指示<code>Cargo</code>包管理器使用本地的<code>stuartZhang/socket2 crate</code>山寨货<strong>替换</strong><code>crates.io</code>上的正品，因为正品<strong>不兼容</strong>华为操作系统。</p>
<p>接着，从<code>VSCode</code>打开<code>src/lib.rs</code>文件，和增补如下<code>Demo</code>代码。这是一段简单的整数加运算程序。<strong>请把注意力聚焦在【派生宏】的使用上</strong>。</p>
<pre><code>use ::ohos_node_bindgen::derive::ohos_node_bindgen;
#[ohos_node_bindgen]
fn add(first: i32, second: i32) -&gt; i32 {
    first + second
}
</code></pre>
<p>再次，执行交叉编译</p>
<pre><code>cargo ohos-build --release
</code></pre>
<p>最后，从【资源管理器】查看编译输出结果</p>
<pre><code>Cargo (Library) Package 工程根目录
├── Cargo.toml
├── src — Rust 源码目录
├── target
│  ├── aarch64-unknown-linux-ohos
│  │  └── release
│  │     └── libcalculator.so
│  ├── armv7-unknown-linux-ohos
│  │  └── release
│  │     └── libcalculator.so
│  ├── x86_64-unknown-linux-ohos
│  │  └── release
│  │     └── libcalculator.so
</code></pre>
<p>值得注意的是，编译输出的链接库文件名是<strong>有<code>lib</code>前缀</strong>的。所以，<code>Native</code>模块的文件名是<code>lib&lt;包名&gt;.so</code>，而不是<code>&lt;包名&gt;.so</code>。</p>
<h2>将<code>Native</code>模块注入普通的<code>DevEco Studio</code>工程</h2>
<blockquote>
<p><code>Native</code>模块就是由前面交叉编译输出的<code>ArkTs N-API</code>链接库<code>.so</code>文件。</p>
</blockquote>
<p>首先，从<code>DevEco Studio IDE</code>新建/打开普通<code>Empty Ability</code>工程。</p>
<p>然后，修改<strong>模块级</strong>的<code>build-profile.json5</code>文件（比如，<code>entry/build-profile.json5</code>），和添加如下配置项至<code>buildOption</code>节点</p>
<pre><code>"externalNativeOptions": {
  "abiFilters": [
    "arm64-v8a",
    "armeabi-v7a",
    "x86_64"
  ]
}
</code></pre>
<p>其次，在模块根目录下，创建下面三个子文件夹</p>
<ul>
<li><code>libs/arm64-v8a</code></li>
<li><code>libs/armeabi-v7a</code></li>
<li><code>libs/x86_64</code></li>
</ul>
<p>接着，依次向它们复制入编译好的链接库文件。例如，</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/a003500d-9f39-4855-8cbd-3e60b8d05a08" alt="image"></p>
<p>最后，在<code>ArkTs</code>业务代码内（比如，<code>entry/src/main/ets/pages/Index.ets</code>），以<code>ES Module</code>语法，导入<code>Native</code>模块，和调用其成员方法</p>
<pre><code>import calculator from 'libcalculator.so';
const result = calculator.add(2, 3);
</code></pre>
<p>总的来讲，调用端的<code>ets</code>代码就这么简单！但还是有三处优化可做以改善开发体验：</p>
<h3>优化<code>DevEco Studio</code>工程目录结构</h3>
<p>将<code>Cargo (Lib) Package</code>与<code>DevEco Studio Project</code>合并为一个工程更有利于提高<code>Rust + ArkTs</code>的混合编程生产力。所以，如下<code>DevEco Studio</code>工程目录结构是被强力推荐的：</p>
<pre><code>DevEco Studio 工程根目录
├── entry — 模块根目录
│   ├── libs — 交叉编译输出的 .so 文件都被复制到下面的子文件夹内
│   │   ├── arm64-v8a
│   │   ├── armeabi-v7a
│   │   └── x86_64
│   ├── src
│   │   ├── main
│   │   │  ├── resources
│   │   │  ├── cpp  — *旧有*的 Cpp(ArkTs N-API) 工程目录
│   │   │  ├── ets  — *旧有*的 ArkTs 源码目录
│   │   │  ├── rust — *新建*的 Rust(ArkTs N-API) 工程目录
│   │   │  │   ├── Cargo.toml
│   │   │  │   ├── src — Rust 源码目录
│   │   │  │   ├── target
│   │   │  │   │  ├── aarch64-unknown-linux-ohos
│   │   │  │   │  │  └── release
│   │   │  │   │  ├── armv7-unknown-linux-ohos
│   │   │  │   │  │  └── release
│   │   │  │   │  ├── x86_64-unknown-linux-ohos
│   │   │  │   │  │  └── release
</code></pre>
<p>将<code>Cargo (Lib) Package</code><strong>降级为</strong><code>DevEco Studio Project</code>内某个特定模块下的<strong>子工程</strong>有两个好处：</p>
<ol>
<li>同一个<code>DevEco Studio</code>工程内可同时包含<strong>多个</strong><code>Native</code>子工程。</li>
<li>每个<code>Native</code>子工程既可<strong>独占</strong>一个模块以达成与主模块业务代码<strong>有限隔离</strong>的目的，也能与<code>ets</code>程序“混住”耦合于相同模块内。</li>
</ol>
<h4>友情提示</h4>
<p>在移动<code>Cargo (Lib) Package</code>工程位置后，千万别忘了同步修改<code>Cargo.toml</code>配置文件中【依赖图重写】配置表<code>[patch.crates-io]</code>对本地<code>stuartZhang/socket2 crate</code>的引用路径。否则，会编译失败！</p>
<p>若假设<code>stuartZhang/socket2 crate</code>与<code>DevEco Studio Project</code>处理于平级目录，那么【依赖图重写】配置表应该改为</p>
<pre><code>[patch.crates-io]
socket2 = { path = "../../../../../socket2" }
</code></pre>
<h3>自动化链接库<code>.so</code>文件的复制操作</h3>
<p>在每次执行<code>cargo ohos-build --release</code>指令之后都徒手复制三个<code>.so</code>文件至不同的文件夹是非常低效的，所以 @Rustacean 有必要给<code>Cargo</code>编写<code>build.rs</code>与<code>post_build.rs</code>构建程序，以扩展包管理器在<strong>编译前</strong>与<strong>编译后</strong>的处理行为，并自动完成文件复制操作。其中，</p>
<ol>
<li><a href="https://github.com/stuartZhang/Arkts-NAPI-Rust-Demo/blob/main/entry/src/main/rust/build.rs" rel="noopener noreferrer">build.rs</a>作为【前置处理】程序
<ol>
<li>从环境变量，收集<code>.so</code>文件的位置信息</li>
<li>生成<code>[CMD] COPY /Y</code>或<code>[Shell] cp -f</code>文件复制指令</li>
<li>将【文件复制】指令尾追加至同一个<code>.cmd / .sh</code>脚本文件</li>
</ol>
</li>
<li><a href="https://github.com/stuartZhang/Arkts-NAPI-Rust-Demo/blob/main/entry/src/main/rust/post_build.rs" rel="noopener noreferrer">post_build.rs</a>作为【后置处理】程序
<ol>
<li>执行被写入【文件复制】指令的程序文件，并</li>
<li>删除该程序文件</li>
</ol>
</li>
</ol>
<blockquote>
<p>【打广告】<code>build.rs</code>与<code>post_build.rs</code>皆未对上下文做任何的假设。所以，它们可被<strong>零成本</strong>地复用于其它同类工程中。</p>
</blockquote>
<p>还是看图吧，一图抵千词</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/891e6a5d-cbfd-453d-b374-c221dc83a186" alt="image"></p>
<p>设计很完美但现实很骨感，因为<code>Mozilla</code>厂方的<code>rustup</code>工具链尚<strong>不</strong>支持【后置处理】。所以，@Rustacean 需</p>
<ol>
<li>
<p>额外安装功能增补包<a href="https://crates.io/crates/cargo-post" rel="noopener noreferrer">cargo-post</a></p>
<pre><code>cargo install cargo-post
</code></pre>
</li>
<li>
<p>修改<code>Cargo</code>全局配置文件<code>%UserProfile%\.cargo\config.toml</code>中的<code>ohos-build</code>别名设置，以使<code>cargo-post</code>生效</p>
<pre><code>[alias]
ohos-build = ["post", "build", "-Zbuild-std", "--target=aarch64-unknown-linux-ohos", "--target=armv7-unknown-linux-ohos", "--target=x86_64-unknown-linux-ohos"]
</code></pre>
<p>【注意】在"build"左侧<strong>新</strong>添加了"post"数组项</p>
</li>
</ol>
<h3>给<code>Native</code>模块导出接口，添加<code>.d.ts</code>类型提示</h3>
<p><code>DevEco Studio IDE</code>并没有集成类似于<a href="https://www.nirsoft.net/utils/dll_export_viewer.html" rel="noopener noreferrer">DLL Export Viewer</a>的【动态链接库外部接口反射工具】。所以需要</p>
<ol>
<li>@Rustacean 在输出<code>.so</code>文件的同时也提供一份接口类型说明的<code>.d.ts</code>文件（— 其功能几乎等效于<code>C</code>头文件），并</li>
<li>将该类型说明文件注入<code>DevEco Studio</code>工作流</li>
</ol>
<p>接下来，我沿着前面<code>Rust + ArkTs</code>混合编程的<strong>新</strong>目录结构，描述操作步骤：</p>
<ol>
<li>
<p>在模块<code>entry</code>的根目录下，创建<code>src/main/rust/types/libcalculator</code>子目录。注意：路径末端的文件夹名<code>libcalculator</code>是链接库文件的<code>basename</code>。</p>
</li>
<li>
<p>在新建文件夹内，再新建文件<code>index.d.ts</code>和添入<code>Native</code>模块导出函数的函数签名</p>
<pre><code>export const add: (frist: number, second: number) =&gt; number;
</code></pre>
</li>
<li>
<p>接着新建文件<code>oh-package.json5</code>和添入<code>Native</code>模块的摘要信息。</p>
<pre><code>{
    "name": "libcalculator.so",
    "types": "./index.d.ts",
    "version": "0.1.0",
    "description": "ArkTs NAPI 原生模块示例"
}
</code></pre>
<p>其中，</p>
<ol>
<li><code>name</code>字段就是链接库的文件名（含扩展名）。</li>
<li><code>types</code>字段是指向类型说明文件的<strong>相对</strong>路径。</li>
<li><code>version</code>字段是<code>Native</code>模块版本号。【推荐】该字段值与<code>Cargo (Lib) Package</code>子工程中<code>Cargo.toml</code>配置文件内<code>[package]</code>配置表下<code>version</code>配置项的值保持一致 — 这又是一处纯人工同步点。</li>
<li><code>description</code>字段是<code>Native</code>模块描述信息。</li>
</ol>
</li>
<li>
<p>打开<code>entry</code>模块的<code>oh-package.json5</code>文件，并添加对<code>Native</code>模块的依赖项条目。</p>
<pre><code>"dependencies": {
    "libcalculator.so": "file:src/main/rust/types/libcalculator"
}
</code></pre>
<p>在依赖项条目中，左侧是链接库的文件名；而右侧是指向了类型说明文件所处文件夹的相对目录。</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/a2190d96-e493-4ad6-8652-ba6fb8598c74" alt="image"></p>
</li>
<li>
<p>最后，从<code>DevEco Studio IDE</code>依次点击菜单项<code>Build</code> ➞ <code>Rebuild Project</code>重新构建整个工程和使配置项修改生效。</p>
</li>
</ol>
<p>于是，鸿蒙应用软件开发程序员就能在<code>ets</code>与<code>ts</code>代码编辑器内获得针对<code>Native</code>模块<code>API</code>的丰富类型提示了。</p>
<h2>线上例程</h2>
<p>我已将上述全部文字描述内容都例程化到<code>github</code>工程<a href="https://github.com/stuartZhang/Arkts-NAPI-Rust-Demo/tree/main" rel="noopener noreferrer">Arkts-NAPI-Rust-Demo</a>内了。线下运行该工程可加强对文章繁杂内容的理解。</p>
<h3>运行例程工程的环境要求</h3>
<ol>
<li><code>rustc 1.75.0-nightly</code></li>
<li><code>VSCode 1.86</code></li>
<li><code>ohsdk 3.1.0(API v9)</code></li>
<li><code>DevEco Studio 3.1.1 Release</code></li>
</ol>
<h3>运行例程工程的具体步骤</h3>
<ol>
<li>
<p>克隆<code>git@github.com:stuartZhang/Arkts-NAPI-Rust-Demo.git</code></p>
</li>
<li>
<p>在<code>VSCode</code>内，</p>
<ol>
<li>打开<code>entry/src/main/rust</code>目录</li>
<li>敲击<code>Alt + T + R</code>键。</li>
<li>从<code>Command Palette</code>下拉列表，依次点击<code>build</code> ➞ <code>ohos-build</code> ➞ <code>--release</code></li>
<li>观察控制台输出日志，等待交叉编译结束。</li>
</ol>
</li>
<li>
<p>在<code>DevEco Studio IDE</code>内，</p>
<ol>
<li>打开工程根目录</li>
<li>启动手机模拟器</li>
<li>敲击<code>Shift + F10</code>键，运行移动端程序</li>
</ol>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/b31b49cd-5925-457d-b414-5f43b4c93461" alt="image"></p>
</li>
</ol>
<h2>结束语与扩展阅读</h2>
<p>搞定【交叉编译】难关仅只是鸿蒙<code>Rust</code>原生开发万里征程的<strong>第一步</strong>。加深对<code>ArkTs - NAPI</code>接口定义的理解才是【形成生产力】的核心任务。好消息是</p>
<ol>
<li>
<p><code>ArkTs - NAPI</code>与<code>nodejs N-API</code>高度相似。至少截至目前，它们的相似度还<code>&gt;= 95%</code>。所以，已熟悉<code>nodejs</code>原生模块编程的“老司机”们上手鸿蒙<code>ArkTs - NAPI</code>应该不难。</p>
</li>
<li>
<p>另外，我在春节假期期间贡献的<a href="https://github.com/stuartZhang/node-bindgen?tab=readme-ov-file#ohos-node-bindgen%E8%BF%98%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8" rel="noopener noreferrer">ohos-node-bindgen crate</a>更可<strong>大幅降低</strong><code>ArkTs - NAPI</code>原生开发的复杂度。请对比下图左右侧的代码量</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/e94fb366-eb02-42c7-a89c-d1c8835a58a5" alt="image"></p>
<p>所以，<a href="https://github.com/stuartZhang/node-bindgen?tab=readme-ov-file#ohos-node-bindgen%E8%BF%98%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8" rel="noopener noreferrer">ohos-node-bindgen crate</a>值得大家点<code>star</code>呀！也请大家给<a href="https://github.com/stuartZhang/Arkts-NAPI-Rust-Demo/tree/main" rel="noopener noreferrer">Arkts-NAPI-Rust-Demo</a>点<code>star</code>！</p>
</li>
</ol>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/3ccc7de3-e0cc-4d0d-8a31-2d2ed466e23c" alt="ohos-node-bindgen摘要"></p>
2024-02-22T18:26:34.351850952+08:00 - 文章标题：Tran v.0.1.11 发布了!
2024-02-22T18:26:34.351906917+08:00 - 文章内容：<p><a href="https://github.com/Borber/Tran/releases/tag/v.0.1.11" rel="noopener noreferrer">Release v.0.1.11</a></p>
<p>已发布 <code>v0.1.11</code> 版本！相比一个月前的 <code>v0.1.9</code> 版本 平均反应速度提升至少 <strong>80ms</strong> 主要改进：</p>
<ul>
<li>支持多显示器</li>
<li>去除 Tray 将 退出 功能合并到面板中</li>
<li>设置界面, 按钮 hover 效果</li>
<li>避免多次启动</li>
<li>锁定快捷键, 去除无关的按键模拟, 提升快捷键响应速度</li>
<li>快快快, 快就完了</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/Borber/PublicPic1/tran/v1/tran-exit.png" alt="tran-exit"></p>
<h1>Tran</h1>
<p>简洁, 快速, 划词翻译</p>
<p><a href="https://github.com/Borber/tran?tab=GPL-3.0-1-ov-file" rel="noopener noreferrer"><img src="https://img.shields.io/github/license/borber/tran?color=%2398cbed&amp;logo=rust&amp;style=for-the-badge" alt="LICENSE"></a>
<a href="https://github.com/Borber/tran/releases" rel="noopener noreferrer"><img src="https://img.shields.io/github/downloads/Borber/tran/total.svg?style=for-the-badge&amp;color=82E0AA&amp;logo=github" alt="Downloads"></a>
<a href="https://www.rust-lang.org/" rel="noopener noreferrer"><img src="https://img.shields.io/badge/-Rust-orange?logo=rust&amp;style=for-the-badge&amp;logoColor=white" alt="Rust"></a>
<a href="https://tauri.app/" rel="noopener noreferrer"><img src="https://img.shields.io/badge/Tauri-blue?logo=tauri&amp;color=1B1B1D&amp;style=for-the-badge" alt="Tauri"></a>
<a href="https://github.com/Borber/tran/releases" rel="noopener noreferrer"><img src="https://img.shields.io/badge/-Windows-blue?logo=windows&amp;style=for-the-badge&amp;logoColor=white" alt="Windows"></a>
<a href="https://github.com/Borber/tran/releases" rel="noopener noreferrer"><img src="https://img.shields.io/badge/-macOS-black?&amp;logo=apple&amp;style=for-the-badge&amp;logoColor=white" alt="MacOS"></a>
<a href="https://github.com/Borber/tran/releases" rel="noopener noreferrer"><img src="https://img.shields.io/badge/-Linux-yellow?logo=linux&amp;style=for-the-badge&amp;logoColor=white" alt="Linux"></a></p>
<blockquote>
<p><strong>Keep it simple，stupid.</strong></p>
</blockquote>
<h1>功能</h1>
<table>
<thead>
<tr>
<th align="center">划词翻译</th>
<th align="center">划过固定</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img src="https://fastly.jsdelivr.net/gh/Borber/PublicPic1/tran/v1/translate.gif" alt="translate"></td>
<td align="center"><img src="https://fastly.jsdelivr.net/gh/Borber/PublicPic1/tran/v1/drag.gif" alt="drag"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th align="center">划过关闭</th>
<th align="center">划过复制</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img src="https://fastly.jsdelivr.net/gh/Borber/PublicPic1/tran/v1/close.gif" alt="close"></td>
<td align="center"><img src="https://fastly.jsdelivr.net/gh/Borber/PublicPic1/tran/v1/copy.gif" alt="copy"></td>
</tr>
</tbody>
</table>
<p><strong>快捷键：</strong> <code>Alt + X</code></p>
2024-02-22T18:26:34.351942293+08:00 - 文章标题：smartscp: better scp
2024-02-22T18:26:34.351999287+08:00 - 文章内容：<ul>
<li>对scp的封装, 自动跳过被 gitignore 的文件</li>
<li></li>
<li>原理
- 用 sshfs 把远程目录挂在本地的临时目录
- 用 xcp 复制文件</li>
</ul>
<p>之前我尝试过用 sftp 传输文件, 但是 sftp 很难控制远程 git 仓库
后来我发现 sshfs 可以操控远程 git 仓库像本地一样简单
因此切换到了 sshfs</p>
<ul>
<li>
<p>基本用法</p>
<ul>
<li>和 scp 一样, 不过传目录不需要 -r 参数</li>
<li>
<pre><code>smartscp remote-host:remote_path local_path
smartscp local_path remote-host
smartscp local_path remote-host:remote_path
</code></pre>
</li>
</ul>
</li>
<li>
<ul>
<li>如果目标目录是缺省的, smartscp  会自动根据原目录相对于 home 的偏移量, 计算目标目录
<ul>
<li>比如source 是 ~/foo/bar, 那会自动传到远程的 ~/foo/bar</li>
<li>
<pre><code>smartscp ~/foo/bar remote-host
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li></li>
<li>
<p>使用场景</p>
<ul>
<li>传 rust 项目的时候,避免传 target/</li>
<li>传 nodejs 项目的时候, 避免传 node_modules/</li>
<li>对于带宽 网速有限的网络环境, 特别有用</li>
</ul>
</li>
<li>
<p>尚不支持的功能</p>
<ul>
<li>包含 : 的文件名</li>
</ul>
</li>
<li></li>
<li>
<p>注意</p>
<ul>
<li>不兼容 scp 的参数, 比如不接受 -r 参数</li>
<li>不要直接替代 scp</li>
<li></li>
</ul>
</li>
<li>
<p>Q&amp;A</p>
<ul>
<li>为什么不用 <code>rsync --exclude=</code>
<ul>
<li>我并不觉得方便</li>
<li>不够自动化</li>
<li>要支持复杂的 gitignore</li>
</ul>
</li>
<li>为什么用rust写
- 为了在源码级依赖 xcp</li>
<li>为什么不从头用rust写一遍 scp, 而不是调用 scp
<ul>
<li>需要不少工作量</li>
</ul>
</li>
<li>为什么不用 c 直接改 scp
<ul>
<li>c 中不太方便导库</li>
</ul>
</li>
</ul>
</li>
</ul>
2024-02-22T18:26:34.352044745+08:00 - 文章标题：更快的 tsv 解析
2024-02-22T18:26:34.352154418+08:00 - 文章内容：<ul>
<li><a href="#%E6%9B%B4%E5%BF%AB%E7%9A%84-tsv-%E8%A7%A3%E6%9E%90" rel="noopener noreferrer">更快的 tsv 解析</a>
<ul>
<li><a href="#%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA" rel="noopener noreferrer">项目搭建</a></li>
<li><a href="#regex-%E8%A7%A3%E6%9E%90" rel="noopener noreferrer">regex 解析</a></li>
<li><a href="#%E5%87%8F%E5%B0%91%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D" rel="noopener noreferrer">减少内存分配</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-ascii-%E6%AD%A3%E5%88%99" rel="noopener noreferrer">使用 ascii 正则</a></li>
<li><a href="#%E6%8A%9B%E5%BC%83-regex" rel="noopener noreferrer">抛弃 regex</a></li>
<li><a href="#%E6%89%8B%E5%86%99%E8%A7%A3%E6%9E%90%E7%8A%B6%E6%80%81%E6%9C%BA" rel="noopener noreferrer">手写解析状态机</a></li>
<li><a href="#simd-%E5%8A%A0%E9%80%9F" rel="noopener noreferrer">SIMD 加速?</a></li>
<li><a href="#%E6%80%BB%E7%BB%93" rel="noopener noreferrer">总结</a></li>
</ul>
</li>
</ul>
<p>最近在B站冲浪时发现一个 Rust 和 Go 解析 tsv 文件的视频, 作者需要解析使用 <code>get-NetTCPConnection | Format-Table -Property LocalAddress,LocalPort,RemoteAddress,RemotePort,State,OwningProcess</code> 获取的本地所有 TCP 连接信息, 文件输出大致如下</p>
<pre><code>LocalAddress                          LocalPort RemoteAddress                     RemotePort       State OwningProcess
------------                          --------- -------------                     ----------       ----- -------------
192.168.1.4                               54339 104.210.1.98                             443 Established          4504
</code></pre>
<p>视频作者使用 regex 正则库处理输出, 发现比 Go 版本慢, 优化后虽然比 Go 快, 但并没有领先多少, 于是我自己尝试使用别的优化方法, 解析耗时能优化使用正则解析的 10% 左右. 下面来看看我的优化过程.</p>
<h2>项目搭建</h2>
<p>进行性能时建议使用 <a href="https://github.com/bheisler/criterion.rs" rel="noopener noreferrer">criterion</a>, 它帮我们解决了性能的内存预加载, 操作耗时, 性能记录, 图表输出等功能.</p>
<pre><code>cargo new --lib tsv
cd tsv
cargo add criterion --dev -F html_reports
cargo add regex
</code></pre>
<p>然后在 Cargo.toml 里添加如 bench 文件</p>
<pre><code>[[bench]]
name = "parse"
harness = false
</code></pre>
<pre><code>// benches/parse.rs
#![allow(dead_code)]
use criterion::{black_box, criterion_group, criterion_main, Criterion};

const OUTPUT: &amp;str = include_str!("net.tsv");

fn criterion_benchmark(c: &amp;mut Criterion) {
    todo!()
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
</code></pre>
<p>测试使用的 tsv 一共 380 行.</p>
<h2>regex 解析</h2>
<p>使用正则解析的正则表达式很简单, 这里直接给代码, 为了避免重复编译正则表达式和重新分配内存报错结果列表, 这里将她们作为参数传给解析函数.</p>
<pre><code>struct OwnedRecord {
    local_addr: String,
    local_port: u16,
    remote_addr: String,
    remote_port: u16,
    state: String,
    pid: u64,
}
fn regex_owned(input: &amp;str, re: &amp;regex::Regex, result: &amp;mut Vec&lt;OwnedRecord&gt;) {
    input.lines().for_each(|line| {
        if let Some(item) = re.captures(line).and_then(|captures| {
            let (_, [local_addr, local_port, remote_addr, remote_port, state, pid]) =
                captures.extract();
            let ret = OwnedRecord {
                local_addr: local_addr.to_string(),
                local_port: local_port.parse().ok()?,
                remote_addr: remote_addr.to_string(),
                remote_port: remote_port.parse().ok()?,
                state: state.to_string(),
                pid: pid.parse().ok()?,
            };
            Some(ret)
        }) {
            result.push(item);
        }
    });
    assert_eq!(result.len(), 377);
}
</code></pre>
<p>parse.rs 文件里要加上使用的正则和提前创建好列表, 并且将函数添加的 bench 目标里</p>
<pre><code>fn criterion_benchmark(c: &amp;mut Criterion) {
    let re = regex::Regex::new(r"(\S+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\S+)\s+(\d+)").unwrap();
    let mut r1 = Vec::with_capacity(400);
    c.bench_function("regex_owned", |b| {
        b.iter(|| {
            // 重置输出 vector
            r1.clear();
            regex_owned(black_box(OUTPUT), &amp;re, &amp;mut r1);
        })
    });
}
</code></pre>
<p>接着跑 <code>cargo bench --bench parse</code> 进行测试, 在我的电脑上测得每次运行耗时 450 µs 左右.</p>
<h2>减少内存分配</h2>
<p>一个最简单的优化是使用 <code>&amp;str</code> 以减少每次创建 <code>String</code> 带来的内存分配和数据复制.</p>
<pre><code>struct Record&lt;'a&gt; {
    local_addr: &amp;'a str,
    local_port: u16,
    remote_addr: &amp;'a str,
    remote_port: u16,
    state: &amp;'a str,
    pid: u64,
}
</code></pre>
<p>两个函数代码差不多, 所以这里不再列出来, 可以通过 <a href="https://gist.github.com/PrivateRookie/3cc2330f9bbeb1115efb4a49f0627298" rel="noopener noreferrer">gits: tsv 解析</a> 获取完整代码.</p>
<p>可惜这次改动带来的优化非常小, 在我的电脑上反复测量, 这个版本耗时在 440 µs 左右.</p>
<h2>使用 ascii 正则</h2>
<p>rust 的 regex 正则默认使用 unicode, 相比于 ascii 编码, unicode 更复杂, 因此性能也相对较低, 刚好要解析的内容都是ascii字符, 使用 ascii 正则是否能提升解析速度呢? regex 有 <code>regex::bytes</code> 模块用于 ascii 解析, 但为了适配字段, 这里不得不使用 <code>transmute</code> 将 <code>&amp;[u8]</code> 强制转换成 <code>&amp;str</code></p>
<pre><code>fn cast(data: &amp;[u8]) -&gt; &amp;str {
    unsafe { std::mem::transmute(data) }
}
fn regex_ascii&lt;'a&gt;(input: &amp;'a str, re: &amp;regex::bytes::Regex, result: &amp;mut Vec&lt;Record&lt;'a&gt;&gt;) {
    input.lines().for_each(|line| {
        if let Some(item) = re.captures(line.as_bytes()).and_then(|captures| {
            let (_, [local_addr, local_port, remote_addr, remote_port, state, pid]) =
                captures.extract();
            let ret = Record {
                local_addr: cast(local_addr),
                local_port: cast(local_port).parse().ok()?,
                remote_addr: cast(remote_addr),
                remote_port: cast(remote_port).parse().ok()?,
                state: cast(state),
                pid: cast(pid).parse().ok()?,
            };
            Some(ret)
        }) {
            result.push(item);
        }
    });
    assert_eq!(result.len(), 377);
}
</code></pre>
<p>添加到 bench 后性能大概多少呢?, 很遗憾, 性能与 regex_borrow 差不多, 在 430 µs 左右.</p>
<h2>抛弃 regex</h2>
<p>鉴于内容格式比较简单, 如果只使用 rust 内置的 split 等方法解析性能会不会更好呢?
解析思路很简单, 使用 <code>lines</code> 得到一个逐行迭代器, 然后对每行使用 split 切分空格再逐个解析即可</p>
<pre><code>fn split&lt;'a&gt;(input: &amp;'a str, result: &amp;mut Vec&lt;Record&lt;'a&gt;&gt;) {
    input
        .lines()
        .filter_map(|line| {
            let mut iter = line.split([' ', '\t', '\r']).filter(|c| !c.is_empty());
            let local_addr = iter.next()?;
            let local_port: u16 = iter.next()?.parse().ok()?;
            let remote_addr = iter.next()?;
            let remote_port: u16 = iter.next()?.parse().ok()?;
            let state = iter.next()?;
            let pid: u64 = iter.next()?.parse().ok()?;
            Some(Record {
                local_addr,
                local_port,
                remote_addr,
                remote_port,
                state,
                pid,
            })
        })
        .for_each(|item| result.push(item));
    assert_eq!(result.len(), 377);
}
</code></pre>
<p>注意 <code>line.split</code> 只后还需要过滤不是空白的字符串, 这是因为字符串 <code>"a   b"</code> split 之后得到 <code>["a", "", "b"]</code>.</p>
<p>经测试, 这个版本测试耗时大概为 53 µs, 这真是一个<strong>巨大提升</strong>, rust 的 regex 性能确实有些问题.</p>
<p>每次 split 之后还需要 filter 感觉有些拖沓, 刚好有个<a href="https://doc.rust-lang.org/std/primitive.str.html#method.split_whitespace" rel="noopener noreferrer">split_whitespace</a>, 换用这个方法, 将新的解析方法命名为<code>split_whitespace</code>后再测试下性能</p>
<pre><code>let mut iter = line.split_whitespace();
</code></pre>
<p>令人意想不到的是性能居然倒退了, 这次耗时大概 60 µs, 仔细研究下来还是 unicode 的问题, 改用 ascii 版本的 <code>split_ascii_whitespace</code> 之后性能提升到 45 µs.</p>
<h2>手写解析状态机</h2>
<p>除了上述的方法, 我还尝试将 Record 的 local_addr 和 remote_addr 改成 <code>std::net::IpAddr</code>, 消除 <code>next()?.parse().ok()?</code> 等其他方法, 但收益几乎没有, 唯一有作用的办法是手写解析状态机.</p>
<p>大致思路是, 对于输出来说, 我们只关系它是以下三种情况</p>
<ol>
<li>换行符 NL</li>
<li>除了换行符的空白符 WS</li>
<li>非空白字符 CH</li>
</ol>
<p>只解析 LocalAddr 和 LocalPort 解析状态机如下, 如果要解析更多字段, 按顺序添加即可.</p>
<pre><code>stateDiagram-v2
    [*] --&gt; LineStart
    LineStart --&gt; LineStart:WS
    LineStart --&gt; ConsumeLocalAddr:Ch
    ConsumeLocalAddr --&gt; LineStart:NL
    ConsumeLocalAddr --&gt; LocalAddr:WS
    ConsumeLocalAddr --&gt; ConsumeLocalAddr:CH
    LocalAddr --&gt; LineStart:NL
    LocalAddr --&gt; LocalAddr:WS
    LocalAddr --&gt; ConsumeLocalPort:CH
    ConsumeLocalPort --&gt; ParsePort:NL
    ConsumeLocalPort --&gt; ParsePort:WS
    ConsumeLocalPort --&gt; ConsumeLocalPort:CH
    ParsePort --&gt; LineDone:parse ok
    ParsePort --&gt; Abort:parse error
    LineDone --&gt; LineStart:NL
    Abort --&gt; LineStart:NL
    LineDone --&gt; [*]:EOF
    Abort --&gt; [*]:EOF
</code></pre>
<p>因为代码有些复杂, 所以这里不再贴出来, 完整代码在 gits 上. 手写状态机的版本耗时大概在 32 µs 左右. 这版本主要性能提升来自手写状态机减少了循环内的分支判断.</p>
<h2>SIMD 加速?</h2>
<p>在上面手写解析的例子里, 处理过程类似与将输出作为一个 vec, 状态机作为另一个 vec, 将两个 vec 进行某种运算后输出结果, 应该能使用 simd 进行加速, 但我还没想出高效实现. 所以这里只给出可能的参考资料</p>
<ol>
<li><a href="https://github.com/liquidaty/zsv" rel="noopener noreferrer">zsv</a> 使用 simd 加速的 csv 解析库</li>
<li><a href="https://mcyoung.xyz/2023/11/27/simd-base64/" rel="noopener noreferrer">simd base64</a> 一篇介绍使用 simd 加速 base64 解析的博客, 非常推荐</li>
</ol>
<h2>总结</h2>
<p>rust regex 在某时候确实存在性能问题, 有时候使用简单的 split 的方法手动解析反而更简单性能也更高, 如果情况允许, 使用 ascii 版本能进一步提升性能, 如果你追求更好的性能, 手写一个状态不失为一种选择, 当然我不建议在生产上这么做. 同时我也期待有 simd 加速的例子.</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzUxMDg5MzUwMA==&amp;mid=2247483749&amp;idx=1&amp;sn=6b1fbad044b2ddef1c8aa360ef81e1c1&amp;chksm=f97d4db6ce0ac4a0fe8a8a5d3062cd99f8bf4f0c2ccc30d41e673df1a5d661aab32c269b1dda#rd" rel="noopener noreferrer">公众号原文</a></p>
2024-02-22T18:26:34.352203186+08:00 - 文章标题：Rust与面向对象（四）
2024-02-22T18:26:34.352621939+08:00 - 文章内容：<h2>原型法</h2>
<p>此原型法非原型模式，而是类似JavaScript中的原型扩展，在JS中，能够很轻松地为String类型“原地”扩展方法，如：</p>
<pre><code>String.prototype.isDigit = function() {
  return this.length &amp;&amp; !(/\D/.test(this));
};
</code></pre>
<p>这个能力其实很好用，但是C++无法这样，一直觉得<code>std::string</code>的功能不足，想为其添加更丰富的如<code>trim</code>/<code>split</code>之类的语义，只能采用继承或者组合代理方式：</p>
<ul>
<li>继承：用一个新类继承<code>std::string</code>，并为新类实现<code>trim</code>/<code>split</code></li>
<li>组合代理：用一个新类组合<code>std::string</code>，并为新类代理所有<code>std::string</code>的方法，包括各类构造方法和析构方法，再为新类实现<code>trim</code>/<code>split</code></li>
</ul>
<p>然后，使用<code>std::string</code>的地方替换成新类。这时候那种都比较复杂，组合的方式更复杂一些，所以也别无脑相信面向对象里“组合一定优于继承”。幸运的是，Rust能轻易完成原型法，比如有个<code>bytes</code>库提供了可廉价共享的内存缓冲区，避免不必要的内存搬运拷贝，<a href="https://docs.rust-embedded.org/rust-sysfs-gpio/bytes/struct.BytesMut.html" title="BytesMut" rel="noopener noreferrer"><code>bytes::BytesMut</code></a>实现了可变缓冲区<a href="https://docs.rust-embedded.org/rust-sysfs-gpio/bytes/struct.BytesMut.html#impl-BufMut" title="BufMut" rel="noopener noreferrer"><code>bytes::BufMut</code></a>，有一系列为其写入u8、i8、u16、i16、slice等基础类型的接口，对于基础的通用的在bytes库中已经足够了，现在有个网络模块，想往<code>bytes::BytesMut</code>中写入<code>std::net::SocketAddr</code>结构，Rust可轻易为<a href="https://docs.rust-embedded.org/rust-sysfs-gpio/bytes/struct.BytesMut.html" title="BytesMut" rel="noopener noreferrer"><code>BytesMut</code></a>扩展实现<code>put_socket_addr</code>：</p>
<pre><code>pub trait WriteSocketAddr {
    fn put_socket_addr(&amp;mut self, sock_addr: &amp;std::net::SocketAddr);
}

impl WriteSocketAddr for bytes::BytesMut {
    fn put_socket_addr(&amp;mut self, sock_addr: &amp;std::net::SocketAddr) {
        match sock_addr {
            SocketAddr::V4(v4) =&gt; {
                self.put_u8(4);        // 代表v4地址族
                self.put_slice(v4.ip().octets().as_ref());
                self.put_u16(v4.port()); 
            }
            SocketAddr::V6(v6) =&gt; {
                self.put_u8(6);        // 代表v6地址族
                self.put_slice(v6.ip().octets().as_ref());
                self.put_u16(v6.port()); 
            }
        }
    }
}
</code></pre>
<p>然后就可以使用<code>BytesMut::put_socket_addr</code>了，只需<code>use WriteSocketAddr</code>引入这个trait就可以，是不是很轻松！为何会这么容易？先看JS的原型法，其背后是原型链在支撑，调用String的方法，不仅在String对象里面查找，还会层层向String的父级、祖父级prototype查找，一旦找到就可以调用，而每个prototype本质上都是个Object，可以获取并编辑它们，ES6的继承本质上也是原型链。所以可以拿到String类的prototype，在它上面为其增加isDigit，就能让所有的String对象都能享受isDigit函数的便利，可谓十分方便。但是C++就不行了，也想拿到<code>std::string</code>的函数表，然后一通编辑为其添加<code>trim</code>/<code>split</code>行为，奈何C++不允许这危险的操作啊，只能派生子类，即便子类仅仅只包含一个<code>std::string</code>。那Rust为何可以，关键就是trait函数表与传统面向对象的虚函数表解藕了，后果就是，类型没有绑死函数表，可以为类型增加新trait函数表，然后就有了上面的Rusty原型法。类似的还可以为Rust的<code>String</code>扩展<code>is_digit</code>/<code>is_email</code>/<code>is_mobile</code>，一样地简单。一般有<code>ext</code>模块，就很可能发现原型法的身影，比如<code>tokio::io::AsyncReadExt</code>。</p>
<p>原型法是最能体现trait函数表与传统面向对象虚函数表分离优势的设计模式！注意，Rust的原型法并没有产生任何新类型，只是增加了一个新的trait函数表，所以一开始称之为“原地”扩展，是比JS更干净的原型法，个人非常喜欢用这个模式，能用就用！更进阶的，Rust还能为所有实现了<a href="https://docs.rust-embedded.org/rust-sysfs-gpio/bytes/struct.BytesMut.html#impl-BufMut" title="BufMut" rel="noopener noreferrer"><code>bytes::BufMut</code></a>的类型扩展实现<code>WriteSocketAddr</code>特型，而不仅仅只为<a href="https://docs.rust-embedded.org/rust-sysfs-gpio/bytes/struct.BytesMut.html" title="BytesMut" rel="noopener noreferrer"><code>bytes::BytesMut</code></a>实现：</p>
<pre><code>/// 可以这样读：为所有实现了ButMut特型的类型实现WriteSocketAddr
/// bytes::BytesMut也不过是T的一种，代码复用性更佳
impl&lt;T: bytes::ButMut&gt; WriteSocketAddr for T {
    fn put_socket_addr(&amp;mut self, sock_addr: &amp;std::net::SocketAddr) {
        // 同样的代码
    }
}
</code></pre>
<p>原型法跟模板方法还有些联系，也算模板方法衍生出来的设计模式，因为子类如果不依赖父类，并且子类还不需要有任何字段，不需要有自己独特的结构就能实现算法策略时，那子类也不用依赖注入到父类了，直接在父类的基础上“原地“扩展，更加轻量。总结一下模板方法的衍生变化：</p>
<p>模板方法：</p>
<ul>
<li>子类拥有自己的结构，并依赖父类的结构和行为才能完成，是模板方法</li>
<li>子类拥有自己的结构，但不依赖父类结构和行为也能完成，可不用继承转而采用组合依赖注入，最好多达2个以上组合，达成策略组合模式</li>
<li>子类不需有自己的结构（或者一个空结构），依赖父类的结构和行为就能完成，只是算法在父类模块中不通用而没实现，可不用继承也不用组合，“原地”扩展，原型法即可</li>
<li>子类不需有自己的结构，也不依赖父类，那这么独立也跟父类没任何关系了，理应属于其它模块</li>
</ul>
<p>回到面向对象，凡是Rust能轻松做到的，面向对象却无法轻松做到的，就是面向对象该被批评的点。。面向对象说我服，早知道也不把虚函数表与对象内存结构绑死了。所谓长江后浪推前浪，新语言把老语言拍死在沙滩上，即便C++20如此强大，不改变虚函数表的基础设计，在原型法上也永远追赶不上Rust语言的简洁。</p>
<h2>装饰器模式</h2>
<p>上节说到，策略模式，要是为复合类型也实现trait，就类似装饰器模式，因为装饰器无论是内部委托成员，还是外部装饰器自己，都得实现同一个名为Decorate的trait，就是为了让它们可以相互嵌套组合：</p>
<pre><code>trait Decorate {
    fn decorate(&amp;mut self, params...);
}

/// 一个静多态的装饰器
struct SomeDecorator&lt;D: Decorate&gt; {
    delegate: D,    // 必要的委托
    ...
}

/// 还得为Decorator自己实现Decorate特型
impl&lt;D: Decorate&gt; Decorate for SomeDecorator&lt;D&gt; {
    fn decorate(&amp;mut self, params...) {
        // 1. SomeDecorator itself do sth about params 
        self.do_sth_about_params(params...); // 这是真正要装饰的实现
        // 2. then turn self.delegate
        self.delegate.decorate(params...);    // 这一句都相同，1、2步的顺序可互换
    }
}

/// 另一个装饰器
struct AnotherDecorator&lt;T: Decorate&gt; {
    delegate: T,
    ...
}

impl&lt;D: Decorate&gt; Decorate for AnotherDecorator&lt;D&gt; {
    fn decorate(&amp;mut self, params...) {
        // 1. AnotherDecorator itself do sth about params 
        self.do_sth_about_params(params...);
        // 2. then turn self.delegate
        self.delegate.decorate(params...);    // 这一句都相同
    }
}

/// 必要的终结型空装饰器
struct NullDecorator;

impl Decorator for NullDecorator { /*do nothing*/ }

/// 使用上
let d = SomeDecorator::new(AnotherDecorator::new(NullDecorator));
d.decorate();
</code></pre>
<p>SomeDecorator/AnoterDecorator是真正的装饰器，会有很多个，功能各异，每个Decorator所包含的相应的结构可能也不同。装饰器在使用上，就像链表一样，一个处理完之后，紧接着下一个节点再处理，它把链表结构包含进了装饰器的结构里面，并用接口/trait来统一类型。上述实现有重复代码，就是调用委托的装饰方法，还能继续改进：</p>
<pre><code>/// 装饰的其实是一个处理过程
trait Handle {
    fn handle(&amp;mut self, params...);
}

trait Decorate {
    fn decorate(&amp;mut self, params...);
}

/// 装饰器的终结
struct NullDecorator;

impl Decorate for NullDecorator {
    fn decorate(&amp;mut self, params...) {
        // do nothing
    }
}

/// 通用型装饰器，像是链表节点串联前后2个处理器节点
struct Decorator&lt;D: Decorate, H: Handler&gt; {
    delegate: D,
    handler: H,   // 这又是个干净的模板方法，将变化交给子类
}

/// 通用装饰器本身也得实现Decorate特质，可以作为另一个装饰器的D
impl&lt;D: Decorate, H: Handler&gt; Decorate for Decorator&lt;D, H&gt; {
    fn decorate(&amp;mut self, params...) {
        // 这两步可互换
        self.handler.handle(params);
        self.delegate.decorate(params);
    }
}

/// 下面的处理器只关注处理器自己的实现就好了
struct SomeHandler { ... };

impl Handler for SomeHandler { ... }

struct AnotherHandler { ... };

impl Handler for AnotherHandler { ... }

/// 使用上
let d = Decorator {
    delegate: Decorator {
        delegate: NullDecorator,
        handler: AnotherHandler,
    },
    handler: SomeHandler,
};
d.decorate(params...);
</code></pre>
<p>可以看出，装饰器很像链表，emm...大家都知道链表在Rust中较复杂，那链表有多复杂，装饰器就有多复杂。上面的静多态实现也是不行的，不同的装饰器组合，就会产生不同的类型，类型可能随着Handler类型数目增加呈其全排列阶乘级类型爆炸，忍不了，必须得换用指针。装饰器模式，Rust实现起来不如传统面向对象，面向对象天然动多态，且Decorator继承可以让D、H两部分合为一体，让H也成装饰类的一个虚函数，都在this指针访问范围内，简单一些。而Rust将装饰器拆解成了链表型，将装饰器的底层结构还原了出来，确实装饰器可以用链表串联起各个处理器一个接一个地调用，效果一样的。只是面向对象技巧隐藏了链表的细节。</p>
<p>不过Rust有个很牛逼的装饰器，就是迭代器的map、step_by、zip、take、skip这些函子，它们可以随意串联组合调用，本质就是装饰器，只不过仅限于用在迭代器场景。如果装饰器能这样实现，能惰性求值，也能够编译器內联优化，就太强了。不过，各个装饰器功能不同，恐怕不能像迭代器函子那样都有清晰的语义，因此没有统一的装饰器库。不过装饰器实现时，肯定可以借鉴迭代器的函子思路。这样一来的话，Rust的装饰器又丝毫不弱于传统面向对象的了。而且，高，实在是高，妙，实在是妙！</p>
<pre><code>/// 以下仅作摘选，让大家一窥迭代器函子的装饰器怎么玩的
pub trait Iterator {
    type Item;

    // Required method
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // Provided methods
    // 像下面这样的函数还有76个，每个函数都映射到一个具体的装饰器，它们都返回一个装饰函子impl Iterator&lt;Item = Self::Item&gt;
    // 装饰器函数基本都定义完了，未来无法扩展？还记得原型法吗，为所有实现了Iterator的类型实现IteratorExt
    // 仅挑选一个step_by作为案例
    #[inline]
    #[stable(feature = "iterator_step_by", since = "1.28.0")]
    #[rustc_do_not_const_check]
    fn step_by(self, step: usize) -&gt; StepBy&lt;Self&gt;
    where
        Self: Sized,
    {
        StepBy::new(self, step)
    }
}

/// StepBy装饰器，如第一种实现那样的写法
pub struct StepBy&lt;I&gt; {
    iter: I,    // 装饰器的delegate
    step: usize,
    first_take: bool,
}

/// 再为StepBy&lt;I&gt;实现Iterator
impl&lt;I&gt; Iterator for StepBy&lt;I&gt;
where
    I: Iterator,
{
    type Item = I::Item;

    #[inline]
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.spec_next()
    }
}

// 使用上，有别于传统装饰器模式从构建上去串联，这是利用返回值链式串联，顿时清晰不少
vec![1, 2, 3].iter().skip(1).map(|v| v * 2);
</code></pre>
<h2>小结</h2>
<p>至此，模板方法的变化告一断落。之前，有人说Rust不支持面向对象，导致Rust不好推广，实际上并不是，哪个OO设计模式Rust实现不了，还更胜一筹。因此，并非Rust不支持面向对象！有些设计模式，Rust天生也有，如：</p>
<ul>
<li>单例模式：其实单例模式如果不是为了懒加载，跟使用全局变量没啥差别；如果为了懒加载，那<code>lazy_static</code>或者<code>once_cell</code>就够用。（补充：标准库已经标准化成<code>OnceLock</code>了）</li>
<li>代理模式：NewType模式作代理挺好；或者原型法“原地”扩展代理行为</li>
<li>迭代器模式：Rust的迭代器是我见过最NB的迭代器实现了</li>
<li>状态机模式：<a href="https://doc.rust-lang.org/stable/book/ch17-03-oo-design-patterns.html" rel="noopener noreferrer">Rust语言官方文档中的NewType+enum状态机模式</a>，这种静多态的状态机非常严格，使用上都不会出错，所有状态组合还可以用enum统一起来，比面向对象的状态机模式要好</li>
</ul>
<p>还有一些设计模式，跟其它模式很像，稍加变化：</p>
<ul>
<li>适配器模式：同代理模式差别不大，很可能得有自己的扩展结构，然后得有额外“兼容处理”逻辑来体现“适配”</li>
<li>桥接模式：就是在应用策略模式</li>
<li>过滤器模式：就是在应用装饰器模式</li>
</ul>
<p>还有一些设计模式，读者可自行用Rust轻松实现，如观察者模式之流。后续不会为这些设计模式单独成文了，除非它有点意思，访问者模式就还可以，只不过实际应用不咋多。有想用Rust实现哪个设计模式有疑问的，可留言交流。</p>
<p>罗列所有设计模式没啥意思，我也无力吐槽这么多设计模式，至今很多人仍区分不清某些设计模式的区别，因为设计模式在描述它们的时候，云里雾里的需求描述，关注点、应用场景不一样云云，什么模式都得来一句让“抽象部分”与“实现部分”分离，跟都整过容一样相似的描述，让人傻傻分不清。至今我再看各种设计模式，想去了解其间区别，都觉得无聊了，浪费时间！被大众广泛记住的设计模式就那么几个，因为基础的设计就那么几个，当你在使用接口、指针/引用、组合的时候，其实就在不知不觉中使用设计模式了。</p>
<p>上段是在批评设计模式没错，并不是说设计模式一无是处，能总结出模式作为编程界通用设计语言意义非凡。懂它肯定比不懂的强，要是都能区分清各类设计模式了，肯定是高手中的高手了，看懂这一系列文章不难。设计模式的套用，归根结底是为了代码复用，良好的可读性。大家看到相似模式的代码，一提那种设计模式就能明白。遗憾的是，即便是同一个设计模式，因为乱七八糟的类型、胡乱命名、粗糙的掺杂不少杂质的实现，为不停变化的需求弄的面目全非者，让人读起来，实在很难对的上有某种设计，这并非设计模式的锅，而是编程素质不专业、太自由发挥、总见多识少地自创概念/二流招式的毛病招致的。</p>
<p>在这方面，Rust的解决方案 <strong>极具</strong> 吸引力。后续对比着面向对象，讲讲Rusty那味，味道不错但更难掌握，属于基础易懂，逻辑一多就复杂(废话)！</p>
2024-02-22T18:26:34.352679290+08:00 - 文章标题：N-API的JS堆对象生命周期管理
2024-02-22T18:26:34.353115095+08:00 - 文章内容：<h1><code>N-API</code>的<code>JS</code>堆对象生命周期管理</h1>
<p><code>N-API</code>是<code>Node API</code>的简写，同时也是<code>nodejs</code>的<code>JS VM</code>（链）接入原生模块<code>.node</code>文件的<strong>应用程序二进制接口</strong><code>(i.e. ABI)</code>。借助<code>N-API</code>引入的抽象隔离，升级<code>nodejs</code>运行时（虚拟机）</p>
<ul>
<li>【编译】不要求对原生扩展模块<strong>重新编译</strong> — 为<code>nodejs</code>的不同版本分别准备不同的原生模块<code>build</code>真的好麻烦。</li>
<li>【运行】不导致原生模块<strong>程序崩溃</strong> — 精读每一版<code>changelogs</code>清单和微调原生模块源码更耗时费力。</li>
</ul>
<p><code>N-API</code>开放接口在<code>nodejs 10+</code>后才逐步稳定，和成为<code>nodejs c-addon</code>的主流编程标准。</p>
<p>不久前，我有机会在工程实践中独立完成“给<code>node-webkit</code>容器编写原生扩展模块的”程序开发任务。虽然扩展模块自身的业务处理逻辑很简单 — 馁馁的“胶水”代码，但其涉及到了跨越多个<code>FFI</code>接口调用的<code>JS</code>对象<strong>缓存</strong>处理。初版程序<strong>缓存不住</strong><code>JS</code>堆内存中的变量值，因为<code>JS VM</code>的<code>GC</code>总是在<code>FFI</code>接口调用的<strong>间隙</strong>回收由原生模块缓存的<code>JS</code>对象和导致程序崩溃。由此，我特意“死磕”<a href="https://nodejs.org/api/n-api.html" rel="noopener noreferrer">C/C++ addons with Node-API</a>厂方文档，在解决工程难题的同时汇总实践收获写下此文。</p>
<p>文章以名词解释统一术语理解开篇，以对比不同版本<code>ABI</code>标准引题，以技术细节展开讨论为依据，最后向读者图文并茂地描述我个人创新的实践方案。</p>
<h2>名词解释</h2>
<h3><code>nodejs c-addon</code></h3>
<p><code>nodejs</code><strong>原生</strong>扩展模块。所谓“原生”是相对<code>JS</code>模块而言的。它必须由【系统编程语言<code>C / Cpp / Rust</code>】编写，并经由<code>nodejs</code>开放接口<code>N-API</code>，</p>
<ol>
<li>接入<code>nodejs</code>的<code>JS VM</code>，并</li>
<li>与<code>nodejs</code>交换数据·互操作。</li>
</ol>
<p>为了文字简练，下文也将其记作为<code>addon</code>。</p>
<p><code>nodejs c-addon</code>与<code>Commonjs Module</code>在科技树上处于相同的生态位，和对“上游”调用端的<code>JS</code>业务代码呈现一致的调用方式。</p>
<h3><code>JS</code>堆对象</h3>
<p>它既包括由<code>JS</code>程序自身构造的对象实例，也包含由系统程序从<code>addon</code>内调用<code>N-API</code>接口（比如，<a href="https://nodejs.org/api/n-api.html#napi_create_object" rel="noopener noreferrer">napi_create_object()</a>）实例化的<code>JS</code>对象。它们都</p>
<ol>
<li>被保存在<code>JS VM</code>的<strong>堆</strong>内存中，和</li>
<li>被<code>Rust</code><strong>栈</strong>内存中的<a href="https://nodejs.org/api/n-api.html#napi_value" rel="noopener noreferrer">napi_value</a>可修改<strong>原始指针</strong>引用。</li>
</ol>
<h3><code>N-API</code>引用计数</h3>
<p>它是指向<code>JS</code>堆对象的“<code>FFI</code>引用计数”智能指针（后文有图，应该会更直观些）。其</p>
<ol>
<li>被保存于<code>JS VM</code>的<strong>堆</strong>内存中，和</li>
<li>被<code>Rust</code><strong>栈</strong>内存中的<a href="https://nodejs.org/api/n-api.html#napi_ref" rel="noopener noreferrer">napi_ref</a>可修改<strong>原始指针</strong>引用。即，<code>addon</code>端<code>Rust</code>程序拿到的是指向了“智能指针”的“指针”。</li>
<li>被用于<strong>阻止</strong><code>JS VM</code>的<code>GC</code><strong>回收</strong>正活跃于<code>addon</code>端的<code>JS</code>堆对象。这就赋予了 @Rustacean 从<code>JS VM</code>外部干预<code>JS</code>对象生命周期的能力。<code>React Native</code>可都做不到这一点。</li>
</ol>
<h3><code>WASM</code>垫片程序</h3>
<p>它既包括由<code>wasm-bindgen-cli</code>生成的<code>JS</code>垫片程序文件，也包含由<code>wasm-bindgen crate</code>导出的<code>Rust</code>开发框架。正是<code>js &lt;-&gt; Rust</code>两端垫片程序的协同配合，<code>JS</code>堆对象才几乎被“投影为”<code>Rust</code>所有权（栈）变量。比如，<code>JS</code>堆对象的<a href="https://docs.rs/wasm-bindgen/latest/wasm_bindgen/struct.JsValue.html" rel="noopener noreferrer">wasm_bindgen::JsValue</a>（<strong>似</strong>智能指针）<strong>结构体</strong>就比<a href="https://docs.rs/nj-sys/latest/nj_sys/type.napi_value.html" rel="noopener noreferrer">nj_sys::napi_value</a>可修改<strong>原始指针</strong>更能发挥<code>Rust</code>类型系统与<code>Borrow / Drop Checker</code>对程序正确性的保障力。没有“黑魔法”，满眼都是对垫片程序开发迭代的<strong>工作量</strong>。</p>
<h2><code>WASM vs. N-API</code>堆对象生命周期管理策略</h2>
<p>简单地讲，生命周期策略的差异取决于【垫片程序】的“薄/厚”。因为<code>WASM</code>应用场景多（包括但不限于：网页、<code>nodejs</code>，<code>wasm-runtime</code>独立虚拟机），社区关注度高，<code>wasm-bindgen</code>工具链迭代速度快，所以，<code>wasm &lt;-&gt; js</code>垫片程序就“厚”。<code>JS</code>堆对象向<code>Rust</code>的“投影”就更像【智能指针】，而不是“裸奔的”原始指针。<code>WebAssembly</code>工作组甚至规划将垫片程序逐步“固化”至<code>wasm-runtime</code>内（比如，<a href="https://github.com/tc39/proposal-weakrefs" rel="noopener noreferrer">TC39弱引用提案</a>与<a href="https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md" rel="noopener noreferrer">引用类型提案</a>等）以完备核心功能。工作量到位自然对接平滑！这不是黑魔法，而是真金白银的血汗努力。</p>
<p>相反，<code>nodejs c-addon</code>的应用场景就要少得多了。所以，技术社区鲜有热情面向<code>N-API</code>开放接口编写功能丰富的<code>addon &lt;-&gt; js</code>垫片程序。于是，@Rustacean 不得不直面</p>
<ol>
<li>“裸奔的”原始指针</li>
<li>简陋的<a href="https://docs.rs/nj-sys/4.0.0/nj_sys/" rel="noopener noreferrer">Rust Bindings</a> —  与<code>C</code>头文件概念对等的<code>Rust</code>语言项</li>
<li>“安慰剂”式的<strong>宏</strong>编程工具。因为缺乏了<code>js</code>垫片程序的协同呼应，几个<code>Rust</code>宏也只是杯水车薪，能“糖”的内容很少。</li>
<li>转移更多精力从【业务逻辑实现】至【<code>FFI</code>编程】，并与各种<code>FFI</code>技术细节做“斗争”。赶快补课<a href="https://rustcc.cn/article?id=98adb067-30c8-4ce9-a4df-bfa5b6122c2e" rel="noopener noreferrer">内存布局理论知识</a>去吧！</li>
</ol>
<p>具体地讲，在<code>Rust - WASM</code>程序上下文中，披上了“智能指针”马甲的<code>JS</code>堆对象几乎完全“锈化”了。@Rustacean 可忽视<code>JS VM</code>垃圾收集器的干扰和：</p>
<ol>
<li><code>static</code>全局缓存<code>JS</code>堆对象。而不必担心<strong>仅</strong>活跃于<code>addon</code>的<code>JS</code>堆对象会被<code>JS VM</code>的<code>GC</code>回收。
<ul>
<li>相对<code>FFI</code>函数的<strong>单次</strong>调用执行周期，<strong>延长</strong><code>JS</code>堆对象的生命周期。</li>
</ul>
</li>
<li><code>{ .. }</code>块作用域限定<code>JS</code>堆对象，<strong>按需</strong>释放不再访问的变量值，提高内存利用效率。就有<strong>多</strong>局部变量的<strong>大</strong>函数而言，这可明显地降低<code>JS</code>堆内存占用的瞬时峰值。
<ul>
<li>相对<code>FFI</code>函数的<strong>单次</strong>调用执行周期，<strong>缩短</strong><code>JS</code>堆对象的生命周期</li>
</ul>
</li>
</ol>
<p>另一方面，<code>N-API</code>没有功能面面俱到的垫片程序。所以，@Rustacean 做不到仅凭<code>Rust</code>基本语法项就对<code>FFI</code>另一端的<code>JS</code>堆对象执行【全局缓存】或【块作用域】按需回收的程序处理。甚至（重点来了），即便<code>JS</code>端代码<strong>刻意</strong>保留了已<code>FFI</code>导出堆对象的引用，<code>addon</code>端（栈内存）所持有的原始指针依旧会，在<code>FFI</code>函数执行之后，丢失其原本指向的值和成为“野”指针。我怀疑<code>JS VM</code>就算没有回收也至少挪动了被导出<code>JS</code>堆对象的内存位置。由此，@Rustacean 需要在<code>addon</code>业务代码中额外实现部分本该由垫片程序完成的“公共服务”功能，包括但不限于：</p>
<ol>
<li>徒手维护<code>N-API</code>引用计数智能指针，以“锁住”<code>JS</code>堆对象不被<code>JS VM</code>的<code>GC</code>回收 — <strong>延长</strong><code>JS</code>堆对象的生命周期。</li>
<li>调用<code>N-API</code>程序接口构造可层叠嵌套的作用域【块】 — <strong>缩短</strong><code>JS</code>堆对象的生命周期。</li>
</ol>
<p>这的确是一次接触底层“自己动手丰衣足食”的机会，但绝对不是什么令人愉快的开发体验。千言万语汇聚一张图（左侧<code>WASM</code>，右侧<code>nodejs c-addon</code>）促成读者思绪的豁然开朗：</p>
<p><img src="https://github.com/stuartZhang/my_rs_ideas_playground/assets/13935927/f18ae535-1ae4-473d-b143-9df2eb09f46c" alt="生命周期策略对比"></p>
<h2><code>N-API JS</code>堆对象生命周期管理的技术细节</h2>
<p><code>addon</code>对<code>JS</code>堆对象生命周期的管理分为如下三种情况（看图吧，一图抵千词）：</p>
<p><img src="https://github.com/stuartZhang/my_rs_ideas_playground/assets/13935927/932b381d-a653-47b0-9fec-d9bba587b606" alt="技术细节"></p>
<p>由上图可见，真实数据被保存于<code>JS</code>端（堆）内存中。<code>Rust</code>端（栈）内存仅持有随时可能失效的原始指针。所以，@Rustacean 需要调用特定的<code>N-API</code>接口，远程操控<code>JS</code>堆对象的活跃周期。但是，<code>N-API</code>接口并不易用。这表现为...</p>
<h3><code>N-API</code>引用计数智能指针不智能</h3>
<ol>
<li>
<p>没有<a href="https://rust-unofficial.github.io/patterns/patterns/behavioural/RAII.html" rel="noopener noreferrer">RAII Guard</a>对活跃引用数量的<strong>自动</strong>跟踪。@Rustacean 还需书面编写<code>N-API</code>接口调用和<strong>人工</strong>增减引用个数跟踪引用复本数量 — 这是传统的缺陷产出“大户”。</p>
</li>
<li>
<p><strong>零</strong>引用数量<strong>不</strong>意味着<code>GC</code>回收。@Rustacean 还需显式地析构掉<code>N-API</code>【引用计数】智能指针实例，才能促使被“持久化于内存”的<code>JS</code>堆对象接受<code>GC</code>回收。否则，内存泄漏！具体作法请参见如下伪码</p>
<pre><code>use ::nj_sys::{napi_delete_reference, napi_reference_unref};
use ::node_bindgen::core::napi_call_result;
let result = Box::into_raw(Box::new(u32::MAX));
// 1. 将引用计数值减一
napi_call_result!(napi_reference_unref(
    &lt;N-API 调用上下文&gt;,
    &lt;N-API 引用计数·智能指针&gt;,
    result // 引用计数减一之后的结果数值
)).unwrap();
let result = unsafe { Box::from_raw(result) };
// 2. 判断减一后的最新引用计数值是否已经归零。
if *result == 0 { // 当且仅当不再有任何 N-API 引用复本还指向该 JS 堆对象时，
    // 3. 显式地释放引用计数智能指针实例。
    napi_call_result!(napi_delete_reference( // 这一步是必须的。要不然，内存就漏了！
        &lt;N-API 调用上下文&gt;,
        &lt;N-API 引用计数·智能指针&gt;
    )).unwrap();
}
</code></pre>
</li>
<li>
<p>只有四类<code>JS</code>堆对象支持<code>N-API</code>引用计数。它们分别是</p>
<ul>
<li><code>napi_object</code> — <code>ECMAScript</code>规范中的<code>Object</code></li>
<li><code>napi_function</code> — <code>ECMAScript</code>规范中的<code>Function</code></li>
<li><code>napi_symbol</code> — <code>ECMAScript</code>规范中的<code>Symbol</code></li>
<li><code>napi_external</code> — 类似于<code>ECMAScript</code>中的<code>Blob</code>，专门引用<strong>进程外</strong>的某种“黑盒<code>opaque</code>”资源。</li>
</ul>
</li>
<li>
<p>若多个<code>N-API</code>引用计数指针实例（注：不是引用复本）都指向同一个<code>JS</code>堆对象，那么只有当全部<code>N-API</code>引用计数指针实例都被<code>napi_delete_reference()</code>处理后，“持久化于内存”的<code>JS</code>堆对象才被允许<code>GC</code>回收。</p>
</li>
</ol>
<h3>可逃逸作用域与作用域提升不实用</h3>
<p>在上图中的（普通）作用域<code>napi_handle_scope</code>禁止其内部的<code>JS</code>堆对象溢出作用域，和向外传值。即，普通作用域是“多入无出”的。</p>
<p>【可<strong>逃逸</strong>作用域<code>napi_escapable_handle_scope</code>】有限松绑了这条限制。它允许作用域像<strong>函数</strong>一样向外输出一个且仅一个值，而输出形式不是<code>Rust</code>块表达式【返回值】，而是<code>JS</code>堆对象【作用域·提升<code>handle promoting</code>】。类比<code>JS</code>动态语言的【变量提升<code>variable hoisting</code>】,</p>
<ul>
<li>相同点：块内声明的变量可从块外引用和访问</li>
<li>不同点：【可逃逸作用域】有且只有一个块内声明的变量可从块外被访问。否则，程序崩溃。</li>
</ul>
<p>所以，可逃逸作用域是“多入单出”的面向实用有限放开。再看图吧，一图抵千词！</p>
<p><img src="https://github.com/stuartZhang/my_rs_ideas_playground/assets/13935927/449a1c82-b037-4370-8d13-dbc7fd773305" alt="可逃逸作用域"></p>
<p>在作用域层叠嵌套的场景下，这绝对是“盛产”缺陷的泥沼。@Rustacean 需要从程序设计之初就努力避免从<code>Rust</code>端远程管理<code>JS</code>变量的作用域。最好从产品架构上，<strong>多用<code>addon</code>构建【业务组件】，少封装【功能模块】，从根本上规避<code>Rust &lt;-&gt; JS</code>复杂互操作出现</strong>。</p>
<h2>智能化<code>N-API</code>引用计数 — “二段式”引用计数优化法</h2>
<p>相比于最低也需要【过程宏】作为抽象工具才能描述清楚的<code>JS</code>堆对象<strong>作用域</strong>，<code>N-API</code>引用计数智能化改造还是有捷径可走的。</p>
<p>简单地讲，将对引用复本数量变化的跟踪任务委托给遵循<code>RAII with Guard</code>设计模式的智能指针<code>std::rc::Rc&lt;napi_ref&gt;</code>处理。然后，<code>addon</code>业务实现代码仅需负责</p>
<ol>
<li>【始】调用<code>napi_create_reference()</code> 接口，构造一个<strong>单复本</strong>引用计数指针实例，锁住<code>JS</code>堆对象不被<code>GC</code>回收。</li>
<li>【末】调用<code>napi_reference_unref()</code>与<code>napi_delete_reference()</code>接口，清空引用复本与析构唯一的引用计数指针实例，解锁<code>GC</code>回收<code>JS</code>堆对象。</li>
</ol>
<p>接着看图，依旧一图抵千词！</p>
<p><img src="https://github.com/stuartZhang/my_rs_ideas_playground/assets/13935927/2b78ea18-225b-4d96-b97c-ba91947df619" alt="二段式引用计数优化法"></p>
<p>于是，整个设计方案的“难点”就聚焦于：</p>
<ol>
<li><strong>监听</strong>智能指针<code>std::rc::Rc&lt;napi_ref&gt;</code>的引用复本清空<strong>事件</strong>，并</li>
<li>在事件处理函数内，调用<code>napi_reference_unref()</code>与<code>napi_delete_reference()</code>接口通知<code>VM GC</code>回收<code>JS</code>堆对象。</li>
</ol>
<p>难点不难，因为<a href="https://rustcc.cn/article?id=a9198cb9-f16c-4e2b-b30e-6c63eed1cd52" rel="noopener noreferrer">Newtypes</a>设计模式允许 @Rustacean</p>
<ol>
<li>对<code>std::rc::Rc&lt;napi_ref&gt;</code>做<code>AOP</code>编程。以</li>
<li>“拦截+重写”<code>std::rc::Rc&lt;napi_ref&gt;</code>的析构函数<code>&lt;Rc as Drop&gt;::drop(&amp;mut self)</code>。于是，</li>
<li>在每个引用复本的析构处理后，都<strong>重新统计</strong>剩余引用复本的数量。最后，</li>
<li>若<strong>没有</strong>剩余引用复本了，就立即调用<code>N-API</code>接口<code>napi_reference_unref()</code>与<code>napi_delete_reference()</code>。</li>
</ol>
<p>文章写得再自恰也不如呈现一段既注释丰富又可独立运行的参考实现[<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=ae0cb8d0a99d1f729d5b9dba3458f009" rel="noopener noreferrer">例程</a>]来得清晰明白。整个例程由四个部分组成：</p>
<ol>
<li>模块<code>nj_sys</code>模拟<a href="https://crates.io/crates/nj-sys" rel="noopener noreferrer">nj_sys crate</a>的部分导出项，因为<code>nj_sys crate</code>并没有入选<code>playground.org</code>的<code>top 100</code>热门依赖包<a href="https://github.com/rust-lang/rust-playground/blob/main/compiler/base/Cargo.toml" rel="noopener noreferrer">榜单</a>。</li>
<li>模块<code>napi_rc</code>包含了对智能指针<code>std::rc::Rc&lt;napi_ref&gt;</code>的<code>AOP</code>封装。</li>
<li>函数<code>napi_export_method()</code>模仿<code>nodejs c-addon</code>的<code>FFI</code>导出函数。</li>
<li>入口函数<code>main()</code>模仿<code>JS</code>程序调用<code>Rust-FFI</code>函数<code>napi_export_method()</code>。</li>
</ol>
<h3>“二段式”引用计数优化方案的裨益</h3>
<ol>
<li>【程序性能】将<code>FFI</code>调用次数减少至一个常量<code>3</code>。</li>
<li>【代码健壮性】将引用复本的数量跟踪任务从易错的人工完成转为机器自动完成。<code>addon</code>业务代码仅需关注引用复本的<strong>个数归零</strong>事件。</li>
</ol>
<h2>结束语</h2>
<p>关于<code>nodejs c-addon</code>技术方向，我这次仅准备了上述偏【编程】内容与大家分享。其实，交叉编译与动态库链接也是一项可以聊出些许深度的话题。比如，如何做到“从一个工程，一个分支，一套<code>Rust</code>程序同时编译出三版<code>.node</code>链接库文件，以分别适用于<code>nodejs / nwjs / electron</code>三款应用程序容器”的呢？。哎！无处不是“黑科技” — 从条件编译，至编译时修改链接目标。在我输出下一篇相关主题的文章前，感兴趣的读者不防率先品鉴我的另一个<code>github</code>工程<a href="https://githubfast.com/stuartZhang/request-window-attention" rel="noopener noreferrer">request-window-attention</a>寻找答案，和给我的工程点个<code>star</code>！</p>
<p>创作不易，值得（文章）点赞，（<code>github</code>工程）点<code>star</code>，和（两者都）转发。</p>
2024-02-22T18:26:34.353188181+08:00 - 文章标题：Rust与面向对象（三）
2024-02-22T18:26:34.353272031+08:00 - 文章内容：<h2>策略模式</h2>
<p>上节说到，模板方法变化一下就能成策略模式，怎么变化的？且看策略模式典型案例：</p>
<pre><code>pub trait Fly {
    fn fly(&amp;self);
}

pub trait Quack {
    fn quack($self);
}

/// 先以静多态的方式实现
/// 似 trait Fly + Quack就是Duck，只是Fly和Quack独立地变化
struct Duck&lt;F, Q&gt; 
where
    F: Fly,
    Q: Quack,
{
    fly_behabior: F,      // 单看这个成员，与模版方法如出一辙
    quack_behavior: Q,    // 一样，将不同的算法部分交给子类去实现
}

impl&lt;F, Q&gt; Duck&lt;F, Q&gt; 
where
    F: Fly,
    Q: Quack,
{
    pub fn new(fly_behavior: F, quack_behavior: Q) {
        Self { fly_behavior, quack_behavior }
    }
}

/// 实现不同的Fly、Quack策略，参考下图，省略...
/// 下图引用自 Oreilly.Head First Design Pattern
</code></pre>
<p><img src="https://pic.imgdb.cn/item/6586c5e3c458853aef85789f.jpg" alt="Duck UML设计图"></p>
<p>以上是策略模式的简单案例，策略模式可以说是模板方法的衍生变化。还记得上一章中第一种模板方法的实现方式不，单看Fly就是模板方法：模板方法里子类完全不依赖父类，干净地完成算法策略，那子类就能够依赖注入到父类中；最好这种子类不止一个，比如不仅有Fly还有Quack，就是纯正的策略组合模式了。了解这种变化可以帮助区分二者，比那说不清道不明的优缺点、适用场景描述能让你更清晰、透彻地认识到两者的差别与联系。</p>
<p>策略模式，公认的妙。上面是静多态实现的策略模式，会遇到类型爆炸的问题，比如有2种飞行方式、3种呱呱叫方式，那总共有2*3=6种复合类型，体现了组合是类型系统中的积类型。在嵌入式上，因为内存环境限制，类型爆炸导致程序大小变大成了问题，不得不改用动多态，以减少类爆炸带来的影响。</p>
<pre><code>/// 动多态，类型统一了，类型也不会爆炸了
struct DynamicDuck {
    fly_behavior: Box&lt;dyn Fly&gt;,
    quack_behavior: Box&lt;dyn Quack&gt;,
}
</code></pre>
<p>面向对象语言，都是动多态，Java对象皆引用，当引用没地方用了就垃圾回收；C++没有指针则玩不转面向对象，只可能将子类指针赋值给父类指针来多态，无法将子类对象赋值给父类对象来多态吧！所以面向对象的策略模式是动多态，天然无类型爆炸问题。</p>
<p>那类型爆炸一定差吗，类型统一就肯定好吗？先讨论下类型爆炸合理不。自然界生物划分“界门纲目科属种”，动物界有那么多动物，比如都是猫科动物，难道老虎和狮子还不配拥有个自己的类型吗，只能共用猫类型吗？要是想为老虎这个类型单独实现点东西，但不想为狮子也实现这个东西，共用猫类型就不行了！这样看起来，接受类型爆炸挺好，类型完整，也没几个类型，程序大小允许就可以，相比于动不动就异步的task、协程，只要不是大规模类型爆炸，可以忍。而类型统一就会造成一种“类型丢失”，它的不良影响发生在后续为Duck添加其它行为时，这些行为并非所有Duck都需要的时候。比如为绿头鸭实现捕猎，为橡皮鸭实现电动，它们不再是所有鸭子都应有的行为，已有点不再适合使用新策略扩展（可不是所有扩展的行为都是鸭子通用型的Swim、Display，策略模式只拣好的说），但动多态却因“类型丢失”而不知所措，这其实是个难处理的点，本质是为了减少类型爆炸而采用动多态统一类型的牺牲。</p>
<pre><code>/// 静多态可以直接别名
type MallardDuck = Duck&lt;...&gt;;
type RubberDuck = Duck&lt;...&gt;;
type DecoyDuck = Duck&lt;...&gt;;


/// 动多态因“类型丢失”，只能使用NewType，并在NewType中约束DynamicDuck。
/// 那这样，类型还是难免爆炸了啊！
struct MallardDuck(DynamicDuck);
struct RubberDuck(DynamicDuck);
struct DecoyDuck(DynamicDuck);

/// 仅为绿头鸭MallardDuck实现捕猎
impl MallardDuck {
    fn hunt(&amp;self) {
        ...
    }
}
</code></pre>
<p>动多态策略模式再往下写很可能就开始坏味道了。为了解决这个问题，各种奇招就来了，如不管三七二十一，先把捕猎行为塞进Duck中，管其它鸭子会不会错用呢；或者，为橡皮鸭RubberDuck、木头鸭WoodDuck也实现个假的捕猎，这样“捕猎”就又符合新的策略了，又能使用策略模式了；又或者，再来次继承把绿头鸭子类化吧，然后单独给绿头鸭实现捕猎。。然而新类型MallardDuck一方面与动多态复合类型的Duck意义有冲突，不得不在文档中留下一句提醒使用者：“如果想用MallardDuck，请勿使用DynamicDuck构建，而是使用更具体的MallardDuck！”；另一方面，其它类型的Duck也需要子类化吗，若是的话岂不是又免不了类型爆炸了！策略模式这时正失去优雅的光环，它还是那个妙不可言的“策略模式”吗？</p>
<p>Rust语言，则可以静多态一路走到黑，<code>Duck&lt;F, Q&gt;</code>类型当参数时一直泛型约束使用下去。这样看起来，静多态是一种挺好的应对策略模式后续变化的解决方案。Rust还有一种方式，可以终止这种“一直”，就是将有限的静多态类型通过enum和类型统一起来，然后再使用时就不必继续用泛型了，用这个enum和类型就好了。这是个好方法，但也有个弊端，enum和类型终止了模块之外的“扩展性”！在模块之外，再也无法为模块内的enum和类型扩展其它Duck实现，而动多态和一直泛型约束的静多态，则仍不失模块外的扩展性。</p>
<p>策略模式还有个问题，值得探讨，Duck也会飞，也会呱呱叫了，那有没有必要为Duck也实现Fly、Quack特型呢？</p>
<pre><code>/// 有没有必要为Duck实现Fly/Quack trait？
impl&lt;F, Q&gt; Fly for Duck&lt;F, Q&gt; 
where
    F: Fly,
    Q: Quack,
{
    fn fly(&amp;self) {
        self.fly_behavior.fly();
    }
}

impl&lt;F, Q&gt; Quack for Duck&lt;F, Q&gt;
where
    F: Fly,
    Q: Quack,
{
    fn quack(&amp;self) {
        self.quack_behavior.quack();
    }
}
</code></pre>
<p>这是个令人迷惑的选项，个人很讨厌这种“都可以”的选项，让人迟迟下不了决策。很多人从“应该不应该”的角度出发，会得到“应该”的答案，Duck应该会飞，所以为Duck实现了Fly特型，后面就可以用Fly来特型约束了。其实，若实现了，就像是另外一个设计模式——装饰器模式了。但我不建议普通的策略模式这样实现，将Fly和Quack组合起来的Duck，不再是飞行策略实现的一种变体，要是RubberDuck也能因满足Fly特型约束，再次充当Duck自己的“翅膀”F，组合成一个新Duck，那这是什么Duck？闹笑话了，一向以“严格”著称的Rust可不喜欢这样做。看起来Duck会飞，和飞行策略的Fly特型有所不同，读者可自行感受，那如何约束Duck，让别人知道Duck也是可飞行的一个类型呢？可以使用AsRef，让鸭子实现<code>AsRef&lt;F: Fly&gt;</code>，意为“Duck拥有飞行的策略”，鸭子自然也会飞，能做所有会飞的类型可以做的事情。</p>
<pre><code>fn fly_to_do_sth&lt;T, F&gt;(fly_animal: &amp;mut T) 
where
    T: AsRef&lt;F&gt;,
    F: Fly,
{
    // Duck也可以作为fly_animal来执行此函数了
}
</code></pre>
<p>注意，这里AsRef跟Deref的区别。AsRef可以实现多次，到不同类型的借用转换，比如Duck同时AsRef&lt;F: Fly&gt;和AsRef&lt;Q: Quack&gt;；而Deref只能实现一次到一个主Target的类型转换，而Fly和Quack无论哪个行为，明显都不足以让Duck为其实现Deref，它的父类动物结构，才值得Duck使用Deref。</p>
<h2>小结</h2>
<p>初识策略模式时，觉得妙不可言，但它其实没提策略模式那逐渐不可控的后续演化，源于为策略模式的复合类型Duck扩展行为时，并非所有Duck都该有这些扩展行为了，它们很可能是某些鸭子独有的，主要原因是动多态造成了“类型丢失”，而解决办法还没法令人满意！因此，策略模式适合后续不再演化的场景。能应对后续演化的，还得是类型完整的静多态思路。</p>
<p>编程的一大挑战就是为了应对变化，开发者知道的招式变化越多，应对的就越从容，使用看起来正确实际上却会逐渐失控的招式，只会味道越来越坏。变化就是“可扩展性”，谈到“可扩展性”，面向对象说这个我熟，“可扩展性”就是面向对象的目标之一啊！先别轻信，完美应对变化可不容易，即便资深的面向对象专家，都不敢说他写的每个东西都真能满足“单一职责”。。单一职责的足够“原子化”吗？面向对象思想有个老毛病，就是不够具体，让人抓不到，又让人以为抓到了，实际上是面向对象规定的东西，包括它的评论、解释大都泛泛而谈，没有一个度，很难意见统一。</p>
<p>（强调一下：因每个人理解层次不同，这一系列文章无意引战，也不想批评C++，只要C++想，就能实现Rust一样的效果，毕竟现代C++无所不能的。面向对象有些问题值得指出、批评，但个人还是认可面向对象的结构之美。这些文章，仅供大家友好交流Rust和面向对象技术，若有迁移一个面向对象项目到Rust重新实现的需求，那可能会有帮助，欢迎大家友好讨论！）</p>
<p>（原创不易，请在征得作者同意后再搬运，并注明出处！）</p>
2024-02-22T18:26:34.353306396+08:00 - 文章标题：Rust与面向对象（二）
2024-02-22T18:26:34.353388169+08:00 - 文章内容：<h2>模板方法</h2>
<p>Rust提供了trait，类似于面向对象的接口，不同的是，将传统面向对象的虚函数表从对象中分离出来，trait仍然是一个函数表，只不过是独立的，它的参数self指针可以指向任何实现了该trait的结构。</p>
<p>从对象中分离出虚函数表的trait，带来了使用上与面向对象一些根本的不同，这在我看来算是“很大”的不同了。让我们以模版方法设计模式为例来感受一下。先想一下，rust怎么依赖trait和结构继承，实现模板方法？所谓模板方法，就是父类留一个空白方法作为虚函数，交给子类实现，这样子类只负责不同的算法部分，是面向对象中很基础很常用的手法了。用Rust语言照葫芦画瓢先描述一下大概框架，如下：</p>
<pre><code>/// 一个父类A
struct A {
    ...
}

impl A {
    fn do_step1_common(&amp;mut self) { ... }

    // 缺省实现，留给子类实现，如果是C++/Java这类面向对象语言，很容易。若是Rust，该怎么搞？
    fn do_step2_maybe_different(&amp;mut self) { ... }

    fn do_step3_common(&amp;mut self) { ... }

    pub fn do_all_steps(&amp;mut self) {
        self.do_step1_common();
        self.do_step2_maybe_different();
        self.do_step3_common();
    }
}

// 具体的某个子类实现
struct A1 {
    a: A,
    ...
}

impl A1 {
    // 开始实现
    fn do_step2_maybe_different(&amp;mut self) {
        // A1提供一种实现
    }
}
</code></pre>
<p>不瞒大家，我初识rust时就被这样一个面向对象上的简单案例，用rust实现给难住了！当时卡在父类看起来像是一个完整的类型，Rust怎么能未卜先知调用子类的方法呢？</p>
<p>其实，Rust要想实现这种效果，不能A1继承A这种了，而是A包含A1子类来实现，反着来，将不同的实现单独拆出来作为trait，再交给子类实现。</p>
<pre><code>trait DoStep2 {
    fn do_step2_maybe_different(&amp;mut self);
}

/// 另一个父类B
struct B&lt;T&gt; {
    t: T, // 或者Box&lt;&amp;dyn DoStep2&gt;
    ...
}

impl&lt;T&gt; B&lt;T&gt; {
    fn do_step1_common(&amp;mut self) { ... }

    fn do_step3_common(&amp;mut self) { ... }
}

impl&lt;T: DoStep2&gt; B&lt;T&gt; {
    pub fn do_all_steps(&amp;mut self) {
        self.do_step1_common();
        self.t.do_step2_maybe_different();
        self.do_step3_common();
    }
}

/// 具体的子类实现
struct B1 {
    ...
}

impl DoStep2 for B1 {
    fn do_step2_maybe_different(&amp;mut self) {
        // B1提供一种实现
    }
}

// 这样，
// B&lt;B1&gt; 相当于面向对象中的 A1
// B&lt;B2&gt; 相当于面向对象中的 A2
</code></pre>
<p>感觉不错，看起来颇为妥当，这种方式已经能在适合它的场景中工作，也是模板方法的体现。对比下，<code>A</code>、<code>B</code>都不是完整的父类实现，<code>A1</code>、<code>B&lt;B1&gt;</code>才是真正的具体类型，且它们都包含了父类的结构，虽然<code>B&lt;B1&gt;</code>的写法有点不合常规。若子类还拥有自己的独立的扩展结构的话，那Rust这种方式更优雅一些，拆分的更原子、更合理。实践中，往往不会这么完美的套用，会复杂很多，比如子类作为具体类型，想访问父类的成员，才能配合完成<code>do_step2</code>，Rust又该怎么做？面向对象的this指针则轻松支持。Rust不可能让<code>B1</code>再直接包含<code>B</code>，那样循环包含了，只能用引用或者指针来存在<code>B1</code>里面，但这样的话，岂不是太麻烦了，循环引用/包含都是我们极力避免的东西，麻烦到都想放弃模板方法了！</p>
<p>为何会有这种差异？因为面向对象的子类this指针其实指向的是整体，子类的函数表是个本身就包含父类的整体；而上述为<code>B1</code>实现DoStep2 trait的时候，self指向的仅仅是<code>B1</code>，并不知道<code>B</code>的存在。那怎么办？得让self指向整体<code>B&lt;B1&gt;</code>，那为<code>B&lt;B1&gt;</code>实现DoStep2行不行？像下面这样：</p>
<pre><code>impl DoStep2 for B&lt;B1&gt; {
    fn do_step2_maybe_different(&amp;mut self) {
        // 这里self可以访问“父类”B的成员了
    }
}
</code></pre>
<p>但回过头来，<code>B::do_all_steps(&amp;mut self)</code>就没法在“父类”B中统一实现了，因为<code>B&lt;T&gt;</code>在<code>B&lt;B1&gt;</code>具象化之前，还不知道哪来的<code>do_step2</code>，因此要在<code>impl B&lt;B1&gt;</code>中实现，每个不同的具像化的子类都得单独实现相同的<code>do_all_steps</code>!你能接受不？</p>
<p>也许你能接受，为每个<code>B&lt;B1&gt;</code>、<code>B&lt;B2&gt;</code>...重复拷贝一遍各自的<code>do_all_steps</code>！本文基于专业探讨，还是要寻找一下编写通用的<code>do_all_steps</code>方法的，有没有？当然是有的，前提是，你得把<code>do_step1_common</code>，<code>do_step3_common</code>也得trait化，然后在用一个trait组合限定搞定，如下：</p>
<pre><code>trait DoStep1 {
    fn do_step1_common(&amp;mut self);
}

trait DoStep3 {
    fn do_step2_common(&amp;mut self);
}

// 因为B&lt;T&gt;是泛型，只需为泛型编码实现一次DoStep1、DoStep3就行
impl&lt;T&gt; DoStep1 for B&lt;T&gt; { ... }
impl&lt;T&gt; DoStep3 for B&lt;T&gt; { ... }


// 最后，实现通用的do_all_steps，还得靠泛型。
// 此时，B&lt;B1&gt;已经满足T，会为其实现下面的函数
// 可以这样读：为所有实现了DoStep1/DoStep2/DoStep3特质的类型T实现do_all_steps
impl&lt;T&gt; T 
where
    T: DoStep1 + DoStep2 + DoStep3
{
    pub fn do_all_steps(&amp;mut self) {
        self.do_step1_common();
        self.do_step2_maybe_different();
        self.do_step3_common();
    }
}
</code></pre>
<p>如何，这样应该能接受了吧。Rust通过把问题解构的更细粒度，完成了任务。客观对比下，面向对象的实现还是简单些，父类的<code>do_step1</code>和<code>do_step3</code>函数永远指向了同一个实现，而Rust靠泛型应该是指向了3个不同的实现？不知道编译期有没有优化，盲猜应该有。可以说语法如此，Rust只能做到如此了。与面向对象的模板方法相比，最后一点小瑕疵，就是要多定义<code>DoStep1</code>、<code>DoStep2</code> 2个trait，并用一个<code>T: DoStep1 + DoStep2 + DoStep3</code>通用类型包含同样实现了<code>DoStep1 + DoStep2 + DoStep3</code>的<code>B&lt;T&gt;</code>，进而代表它。可我们想仅仅为<code>B&lt;T&gt;</code>类型实现，其他类型也不太可能这样实现了，一个T则把范围不必要地扩大了。要是能按照我们想要的，就仅为<code>B&lt;T&gt;</code>且实现了<code>DoStep2</code>的<code>B&lt;T&gt;</code>来实现<code>do_all_steps</code>，就完美了。要做到此种程度，必须能对自身Self进行限定，如下：</p>
<pre><code>/// 可以这样读：为所有自身实现了DoStep2的B&lt;T&gt;实现do_all_steps
impl&lt;T&gt; B&lt;T&gt;
where
    Self: DoStep2
{
    pub fn do_all_steps(&amp;mut self) {
        self.do_step1_common();
        self.do_step2_maybe_different();
        self.do_step3_common();
    }
}
</code></pre>
<p>这种写法还真可以，也不用额外定义DoStep1、DoStep3了，因为本身<code>B&lt;T&gt;</code>已经有<code>do_step1_common</code>/<code>do_step3_common</code>的实现了，Rust最新的稳定版就支持这样写！</p>
<p>一段完整的Rust代码，可以参考<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=b80de6d4e6d75bf59bb37db386264fed" rel="noopener noreferrer">这里：https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=b80de6d4e6d75bf59bb37db386264fed</a></p>
<p>一个小小的模板方法，Rust分离出2种不同的方式，这是模板方法设计模式都没提到的，2种方式还各有韵味。从定义的顺序上，C++的模板方法，是 <strong>“子类后续扩展父类”</strong> ，Rust的模板方法，则是 <strong>“父类提前包含子类泛型”</strong> ，写法上还真是一开始不太好扭过来。可一旦扭转过来，发现Rust挺强，仍不失面向对象技巧。</p>
<p>反观面向对象，一个模板方法案例，让大家看到了些许面向对象的束缚，其实也无伤大雅，面向对象也能用纯组合的方式实现模板方法，也不用继承，如果需要组合的对象再通过构造动态传递进来，那就跟策略模式很像了，这种组合传递来的对象不止一个时，就是策略模式！然后，让我想起了一个小争论，子类应该严格不准访问父类的成员，让父类的变化完全掌控在父类手中。面向对象的确可以做到，全部private。但Rust的处理方式，显示出了其对这些细节的语法表达更合乎逻辑。</p>
<h2>总结</h2>
<p>模板方法是面向对象虚函数继承的基本应用，是面向对象很多设计模式的基础，如装饰器模式。一篇讲解下来，Rust从一开始别别扭扭到更好地支持模板方法，其实能体会到，Rust强迫你去拆解，即便都是同一个模板方法，但不同的细节要求，子类是否需要访问父类，都有不同的处理变化，分出来的形式还更严格。写到最后，Rust都感觉不到面向对象那味了，那是什么味？</p>
2024-02-22T18:26:34.353426353+08:00 - 文章标题：Rust与面向对象（一）
2024-02-22T18:26:34.353502696+08:00 - 文章内容：<h2>前言</h2>
<p>我个人是修炼了多年的面向对象技术，这一点，相信很多同道中人跟我一样，经历了面向对象的洗礼，毕竟面向对象技术从上世纪七十年代就开始展露头角，是当时的先进编程思想，其理念符合人类对事物的认知方式；近二十多年，都是面向对象技术盛行。面向对象发展至今，有很多优美设计，诸如经典面向对象设计模式中的策略模式、装饰器模式等等，做UI系统时，组合模式+装饰器模式的绘制、ui树管理，别提多优美了，职责链处理UI交互事件，完美应对事件冒泡，简单又令人惊叹。继承、封装、多态，从它们被发明以来，一直有它伟大的意义。要说，Rust超越了面向对象，那内心还得问一句，装饰器在Rust中怎么实现，能不能实现的比面向对象更简单、易懂且优雅？当然，面向对象，也有其缺点，为人诟病的有对象间的相互调用关系混乱，将对象视为有限状态机封装导致的不利于并行等，这些表明面向对象不似它宣传的那么好，并不适合所有场景，这些场景呼唤更好的解决方案。</p>
<p>在Rust社区有不少对面向对象的讨论，这种讨论非常有意义，体现了某些编程设计上本质的东西，这也是我喜欢Rust这门语言的原因之一。作为Rust初学者，一开始我还不是很了解Rust所谓的“超越面向对象”体现在哪里，只能说一知半解、半推半就。一开始会觉得Rust对面向对象批判之后，然后就提了个Trait+Enum和类型的解决方案，就这？代替面向对象那么多设计模式的方案也没多少，就一个更严格的NewType状态机？面向对象可不止一个状态机模式！不免让人生疑：Enum在module之外，其子类扩展性何在？面向对象的诸多优秀设计，还能在Rust语言上良好表达吗？</p>
<p>有时会觉得，面向对象有时候比Rust的Enum、Trait表达能力差的并不多，甚至更好，却足以引发舌战；Rust有时比面向对象强的也不多，也足以引发对面向对象的批判。这种争论本身也没啥好不好，争论多了，自然就能发现什么了。但有时候，我们就是这么容易争论，而实际上，我们连对争论的本质问题是什么，都没搞清。</p>
<p>对Rust入门以后，再看Rust的设计，能意外地发现它想表达的东西了，很开心。现在，把这些对面向对象和Rust理解整理对比下，很多文章都介绍过，这一系列文章，将采用Rust尝试实现各种面向对象技巧的方式来叙述，目标是寻找Rust达成这些技巧的替代方案，同时搞清楚面向对象设计的问题在哪里，及Rust的改良又体现在哪里。
并不否定面向对象技术，也不会通过贬低它来宣示Rust的好，各有值得学习的东西，都有自己适用的领域。非要说的话，面向对象技术现在更普及易懂，是大部分编程人员的必修课，应该沉淀为基操；Rust则更艰涩高深，但其逻辑表达确实更基础，潜力更大。</p>
<h2>面向对象之结构继承</h2>
<p>一切先从最简单的开始。面向对象届有句老话：“多用组合，少用继承”，被奉为圭臬，很多对代码的批评就源自于没遵守它。让我们对比一下：</p>
<pre><code>struct A {
    x: int,
}

struct B1 extends A {
    y: int,
}

struct B2 {
    a: A,
    y: int,
}

</code></pre>
<p>B1好，还是B2好？其实无法回答的。然而，看下B1、B2这两者的内存布局，会惊讶的发现，它们其实是一样的。</p>
<p>看到这里，我第一次怀疑，这么多年的“继承” vs “组合”的争论，是否有必要，我们怎么会这么傻，为了一个相同的东西，还能喋喋不休了这么多年🐶。</p>
<p>不过，有人可能会问了，这种只是内存布局一样，实际上能一样吗，B1、B2对x的访问是不一样的。</p>
<pre><code>// B1是这样访问x的
int get_x = b1.x;

// 而B2是通过a访问的
int get_x = b2.a.x;
</code></pre>
<p>确实不一样，但实际上<code>b2.x</code>可以看成<code>b2.a.x</code>的语法糖。到最终编译到的汇编语言层面，真也的确如此。Rust语言可以轻松使用Deref特质实现该语法糖，连调用A的方法都能一并简化。</p>
<pre><code>impl Deref for B2 {
    type Target = A;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.a
    }
}
</code></pre>
<p>所以，别在讨论，该用组合还是该用继承了！继承本身就是组合，还有啥好讨论的，就算是多继承的概念，也等同于组合多个不同结构。</p>
<p>了解到这一点，对底层而言，"is-a"就是"has-a"，高级语言为其发明了“继承”，此时显的多此一举。底层结构上都一样，所以go语言的结构继承，看上去就是组合，rust亦如此。继承就是一种特殊的组合！</p>
<p>但组合可不仅仅是继承，组合变化更多。组合还可以包含一个“指针”型结构，"has-a-ref"，这在链表、树这种自包含结构里尤其关键；组合还能包含一个集合——"has-many"，"has-a"都可以看成是"has many"的特例，比如树包含不止一个枝干。</p>
<pre><code>// 表达能力上，B3更强，B1、B2都可以用B3来表示，B2不过是B3中包含长度为1的向量
struct B3 {
    a: Vec&lt;A&gt;,
    y: int,
}
</code></pre>
<p>面向对象的一个尴尬就是，本身继承的底层结构是组合，功能上也不如组合，却把“继承”提高到“三大概念”的核心层次，因小失大，以偏概全。从这点看，"has-a"拥有相同结构，加上"is-a"的语法糖，所以go、rust，概念更少，还能表达出“继承”，亦不失组合的含义，更受欢迎。</p>
<p>但话说回来，面向对象，其实有个关键的语法习惯改进，即以对象为主语的调用方式，类自然语言的“主-谓”或者“主-谓-宾”语句，终于不用主语倒置了，现在大部分语言都是默认如此了，Rust也是如此。这时候再考虑继承，若论直接使用父类的谓词行为，则是“is-a”的继承独有的，“has-a”/“has-a-ref”都要借助语法糖或者重新实现父类接口来表达这种"is-a"父类的行为。“has-many”如果也能表现出"is-a"的特性，那就是经典的组合模式了。不过大多时候是“has-many”表现不出“is-a”的特性，仅仅是一种集合管理。</p>
<pre><code>impl DrawWidget for A {
    fn draw(&amp;self, canvas: &amp;mut Canvas) {
        ...
    }
}

// B1已天然实现了DrawWidget，仍可选覆盖实现
// impl DrawWidget for B1 { ... }

// B2则需要实现“is-a”。在Rust语言里，即便B2实现了Deref，也不代表着
impl DrawWidget for B2 {
    fn draw(&amp;self, canvas: &amp;mut Canvas) {
        self.a.draw(canvas);
        // draw y
    }
}

// B3是“has-many”，但本身也可以看成是一个Widget的话，那就是面向对象中经典的组合模式
impl DrawWidget for B3 {
    fn draw(&amp;self, canvas: &amp;mut Canvas) {
        for child in self.a {
            child.draw(canvas);
        }
        // draw y
    }
}
</code></pre>
<p>总结一下，"has"包括</p>
<ul>
<li>"has-a"
<ul>
<li>若意义等同于"is-a"，则为继承；包括"has-(a,b)"等同于"is-(a,b)"型，多继承概念</li>
<li>若不等同于"is-a"，则为简单的包含关系，如一个数据包包含包头和包体，一个分数包含分子和分母等</li>
<li>有时候，即可以用继承，也可以用组合，比如代理模式，就有继承代理和组合代理2种，其结构本相同，何须再分出你我，这就是面向对象不必要的高级概念复杂化</li>
<li>"has-a"还可以是"has-a-ref"，C/C++中包含一个其他结构的指针成员，内存结构不同于继承，却也能形如继承，是组合的一种，链表这类自包含结构必备</li>
</ul>
</li>
<li>"has-many"
<ul>
<li>若还有跟"is-a"一样的特性，就是组合模式</li>
<li>普通的集合管理</li>
</ul>
</li>
</ul>
<p>回到面向对象语义/语言，要问该选哪一种，就看那种能更精准地表达，猫是动物、鸭子是动物，这种就是继承，猫、鸭子继承了动物，肯定比猫、鸭子包含一个动物结构好。而树包括枝干，就是包含关系好。高级语言，对同一结构不同表达，怎么方便人理解怎么来，如此而已。</p>
<p>在Rust语言中，则没了继承的概念，都是组合。因为Rust的Deref，让Rust保留了继承的部分功能性，并没有关闭面向对象的大门。但需注意，B2并未因Deref自动继承实现A所有的特质。Rust舍弃了高级语言复杂的“继承”概念，把底层是什么样就是什么样的组合原汁原味地展现出来，同时保留下其他变化，既继承的弊端可以被摒弃替换成组合或者特质实现的变化，这种变化也许才是那更常见的大多数情况，废除“继承”可能会是未来语言的标准做法。</p>
<h2>结束语</h2>
<p>本篇到这里暂时就结束了，因为篇幅不宜太长，先行文至此，一篇围绕一个小主题。本文仅仅讨论了面向对象的结构继承。面向对象的结构继承，其实狭隘了，从内存结构布局上看，仅仅是组合的一种特例，还不如说成就是组合，组合意义更广泛。有时候，不妨把底层的概念直接暴露出来，也没增加复杂度，理解上会更直白。</p>
<p>Rust也为结构继承留下了Deref的方案，不过请留意，Deref并没让子类自动继承实现父类的特型，只是一个解引用的语法糖，而且一个结构只能实现一次Deref到一个Target。Deref并非仅为结构继承而生，Rust也没怎么提倡用Deref式的继承，官方文档从来没说它是用来对标“继承”的，倒是不少开源项目，拿它映射继承，如果符合“is-a”的意义，还挺适用的。</p>
<p>继承仍有些问题、冲突没展示出来，后面再继续探讨。包括Deref这种具备关联类型的特质，它到后面也不再仅是一个语法糖，在表达实现逻辑语义时，子类没必要实现父类的特型，在特型限定时它们将有更丰富的逻辑表达意义。</p>
2024-02-22T18:27:39.628525387+08:00 - start
2024-02-22T18:27:39.628591987+08:00 - 访问 https://rustcc.cn/rss 开始
2024-02-22T18:27:39.628659056+08:00 - 访问 https://rustmagazine.org/feed.xml 开始
2024-02-22T18:27:39.628688864+08:00 - 访问 https://readrust.net/all/feed.rss 开始
2024-02-22T18:27:39.726406712+08:00 - starting new connection: https://rustcc.cn/
2024-02-22T18:27:39.727453594+08:00 - starting new connection: https://readrust.net/
2024-02-22T18:27:39.729556006+08:00 - starting new connection: https://rustmagazine.org/
2024-02-22T18:27:43.601138794+08:00 - RSS2
2024-02-22T18:27:43.610631059+08:00 - Atom
2024-02-22T18:27:43.619021226+08:00 - RSS2
2024-02-22T18:27:43.619089078+08:00 - 文章标题：【Rust比赛】vivo 蓝河操作系统创新赛火热报名中，75万奖金池等你来挑战！
2024-02-22T18:27:43.619140161+08:00 - 文章内容：<h2>活动介绍</h2>
<p>【vivo蓝河操作系统创新赛】是开放原子开源大赛下设的独立赛项，由vivo联合承办，包含“蓝河代码转译工具”、“蓝河创新应用开发”两大赛题。</p>
<p><a href="https://mp.weixin.qq.com/s/uMBX-zy_XH2iO9WfFLEBWQ" rel="noopener noreferrer">更多比赛信息请参考文章</a></p>
<h3>01 蓝河代码转译工具</h3>
<p>赛题说明：
参赛者需要设计并实现一个具有与蓝河系统/应用相关的代码转译能力的工具程序，完成与蓝河系统/应用相关的代码转译，从而加快操作系统关键技术的突破，从源头保障操作系统内存安全，促进操作系统底层技术发展，加速操作系统生态建设。</p>
<p><a href="https://competition.atomgit.com/competitionInfo?id=d8a588f9ef9b2d1686cc292c3b032f7b" rel="noopener noreferrer">报名入口&gt;&gt;</a></p>
<h3>02 蓝河创新应用开发</h3>
<p>赛题说明：
参赛者基于蓝河操作系统，通过学习蓝河应用开发标准，基于蓝河系统提供的开放能力和用户真实的使用场景，结合 AI 能力，开发出具有创新性的应用，繁荣蓝河生态。</p>
<p><a href="https://competition.atomgit.com/competitionInfo?id=c50d174fbf4d55a7172b25cb784258f8" rel="noopener noreferrer">报名入口&gt;&gt; </a></p>
<h4>注1：</h4>
<p>赛道1主要是C转译Rust的工具方面，非常适合所有 Rust 同学参与，尤其是对操作系统感兴趣的；赛道2主要是基于蓝河操作系统的开放API实现应用开发，且系统自带AI能力加持，几乎适合所有开发同学，非常类似于小程序那一套，从界面交互到数据和网络通信，很容易上手，且提供专用的IDE。</p>
<h4>注2：</h4>
<p>蓝河操作系统 BlueOS 系统架构介绍 <a href="https://blueos.vivo.com/" rel="noopener noreferrer">https://blueos.vivo.com/ </a></p>
<p>蓝河操作系统 BlueOS 开放能力、API、开发工具、教程与文档 <a href="https://developers.vivo.com/product/blueOpen/ability" rel="noopener noreferrer">https://developers.vivo.com/product/blueOpen/ability</a></p>
<h5>预祝各位参赛选手获得大奖！</h5>
2024-02-22T18:27:43.619210307+08:00 - 文章标题：有没有好用的crates发布工具
2024-02-22T18:27:43.619256173+08:00 - 文章内容：<p>现在一个工程下面有多个crates,而且有依赖关系，可不可以把release(包括发布到crates.io/编译各个平台的二进制/制作docker上传到docker hub/自动在github写release)流程实现一个github action,让其自动化，其中发布到crates.io的时候版本号的更新是一个非常繁琐的过程，稍微不小心就会出错，这块如果也能自动化就好了，各位如果有这方面经验的可以借鉴一下，在网上找了一些例子和工具：</p>
<p>工具，不知道好不好用：</p>
<p><a href="https://github.com/Byron/cargo-smart-release" rel="noopener noreferrer">https://github.com/Byron/cargo-smart-release
</a></p>
<p><a href="https://github.com/pksunkara/cargo-workspaces" rel="noopener noreferrer">https://github.com/pksunkara/cargo-workspaces</a></p>
<p>例子：
<a href="https://github.com/svenstaro/miniserve/blob/master/.github/workflows/build-release.yml" rel="noopener noreferrer">https://github.com/svenstaro/miniserve/blob/master/.github/workflows/build-release.yml</a></p>
<p>blog:</p>
<p><a href="https://blog.orhun.dev/automated-rust-releases/" rel="noopener noreferrer">https://blog.orhun.dev/automated-rust-releases/</a></p>
2024-02-22T18:27:43.619285220+08:00 - 文章标题：【Rust日报】2024-02-20 cve-rs 编写安全代码来让 Rust 不内存安全！
2024-02-22T18:27:43.619322938+08:00 - 文章内容：<h3>cve-rs 编写安全代码来让 Rust 不内存安全！</h3>
<p>cve-rs 允许你编写安全代码来在 Rust 程序中引入内存安全漏洞。给出的所有的例子都没有使用 <code>unsafe</code> 代码块。</p>
<p>cve-rs 主要实现了这三种安全问题：</p>
<ul>
<li>Use after free</li>
<li>Buffer overflow</li>
<li>Segmentation fault</li>
</ul>
<p>比如这是一个 UAF 的问题实例：</p>
<p><img src="https://raw.githubusercontent.com/Speykious/cve-rs/main/segfault-demo.png" alt="uaf"></p>
<p>ReadMore: <a href="https://github.com/Speykious/cve-rs/tree/main" rel="noopener noreferrer">https://github.com/Speykious/cve-rs/tree/main</a></p>
<h3>又一个 Rust 实现的命令行版贪吃蛇游戏</h3>
<pre><code>cargo install snakepipe

# basic usage
snakepipe gamestate|snakepipe render

# change the defaults
snakepipe gamestate --frame-duration 80 --width 70 --height 20 --snakepipe-length 15|snakepipe render

# call help on any of the commands
snakepipe --help
</code></pre>
<p>ReadMore: <a href="https://github.com/topheman/snake-pipe-rust" rel="noopener noreferrer">https://github.com/topheman/snake-pipe-rust</a></p>
<h3>使用 Rust 编写一个语言解释器</h3>
<p>目前已经更新了 6 篇文章了， 涵盖简介、词法分析、语法分析、类型表示、执行环境、执行I 等，对编译原理感兴趣的可以关注一下</p>
<p>ReadMore: <a href="https://buildingwithrust.substack.com/archive" rel="noopener noreferrer">https://buildingwithrust.substack.com/archive</a></p>
<hr>
<p>From 日报小组 Koalr</p>
<p>社区学习交流平台订阅：</p>
<ul>
<li><a href="https://rustcc.cn/" rel="noopener noreferrer">Rustcc论坛: 支持rss</a></li>
<li><a href="https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" rel="noopener noreferrer">微信公众号：Rust语言中文社区</a></li>
</ul>
2024-02-22T18:27:43.619351879+08:00 - 文章标题：Rust中的Fn、FnMut 和 FnOnce都有什么区别？
2024-02-22T18:27:43.619370325+08:00 - 文章内容：<p>在 Rust 中，Fn、FnMut 和 FnOnce 是三个用于表示闭包类型的 trait。闭包是一种可以捕获其环境变量的函数。在创建闭包是会默认实现这几个 trait 中的一个。
以下是三个 trait 的区别：</p>
<p>Fn：Fn 是最基本的闭包 trait。它表示闭包可以捕获其环境变量的不可变引用。</p>
<p>FnMut：FnMut 表示闭包可以捕获其环境变量的可变引用。这意味着闭包可以修改其环境变量的值。</p>
<p>FnOnce：FnOnce 表示闭包只能调用一次。它表示闭包可以捕获其环境变量的所有权。这意味着闭包可以移动其环境变量的值。</p>
<p>武汉/深圳，后端开发，专属内推通道</p>
2024-02-22T18:27:43.619380722+08:00 - 文章标题：请问有没原生的类似minhook的crate
2024-02-22T18:27:43.619405137+08:00 - 文章内容：<p>retour有hook函数，可是没发现有在某地址写jmp跳转到分配的内存的功能</p>
2024-02-22T18:27:43.619421971+08:00 - 文章标题：结构体包含另一个结构体引用时，serde序列化问题
2024-02-22T18:27:43.619442274+08:00 - 文章内容：<p>代码如下</p>
<pre><code>use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct Person {
    id: String,
    name: String,
}

#[derive(Serialize, Deserialize)]
struct Msg&lt;'a&gt; {
    id: String,
    person: &amp;'a Person,
}

fn main() {
    let person = Person {
        id: "123".to_string(),
        name: "Alice".to_string(),
    };

    let msg = Msg {
        id: "456".to_string(),
        person: &amp;person,
    };

    let msg_str = serde_json::to_string(&amp;msg).unwrap();
    println!("Serialized Msg: {}", msg_str);
}
</code></pre>
<p>报错如下</p>
<pre><code>error[E0277]: the trait bound `&amp;'a Person: Deserialize&lt;'_&gt;` is not satisfied
    --&gt; src/main.rs:2463:13
     |
2463 |     person: &amp;'a Person,
     |             ^^^^^^^^^^ the trait `Deserialize&lt;'_&gt;` is not implemented for `&amp;'a Person`
     |
note: required by a bound in `next_element`
    --&gt; /home/alxps/.cargo/registry/src/index.crates.io-6f17d22bba15001f/serde-1.0.195/src/de/mod.rs:1726:12
     |
1724 |     fn next_element&lt;T&gt;(&amp;mut self) -&gt; Result&lt;Option&lt;T&gt;, Self::Error&gt;
     |        ------------ required by a bound in this associated function
1725 |     where
1726 |         T: Deserialize&lt;'de&gt;,
     |            ^^^^^^^^^^^^^^^^ required by this bound in `SeqAccess::next_element`
help: consider removing the leading `&amp;`-reference
     |
2463 -     person: &amp;'a Person,
2463 +     person: Person,
     |

</code></pre>
<p>我不想让msg有person所有权，也不想clone person，现在要自定义序列化实现trait，要怎么写？或者有没有其他方法</p>
2024-02-22T18:27:43.619473404+08:00 - 文章标题：krpc-rust v0.2.0 发布，兼容Dubbo协议支持服务注册与发现
2024-02-22T18:27:43.619528840+08:00 - 文章内容：<h1><code>krpc-rust</code> 一个最像RPC框架的Rust-RPC框架</h1>
<p>krpc-rust是一个高性能，轻量级的rpc框架，通过使用Rust宏来解决目前主流rpc框架使用复杂，性能低等问题，不需要通过脚本和脚手架生成rpc调用代码，通过宏来进行编译期"反射"来实现高性能的调用，来满足rpc调用的简易性，同时支持Dubbo3服务的注册发现和互相调用;</p>
<h2>快速开始</h2>
<h3>Server</h3>
<pre><code>#[derive(Serialize, Deserialize, Default, Debug)]
struct ReqDto {
    name: String,
}

#[derive(Serialize, Deserialize, Default, Debug)]
struct ResDto {
    res: String,
}

#[derive(Clone)]
struct DemoService {
    _db: String,
}

krpc_server! {
   //设置包路径
   "org.apache.dubbo.springboot.demo",
   //设置service-name
   DemoService,
   //设置service-versions
   None,
   async fn sayHello(&amp;self,req : String) -&gt; Result&lt;String&gt; {
      info!("res : {:?}" ,req);
      return Ok("Hello ".to_owned() + &amp;req);
   }
   async fn sayHelloV2(&amp;self,req : ReqDto) -&gt; Result&lt;ResDto&gt; {
      info!("res : {:?}" ,req);
      return Ok(ResDto{res :  "Hello ".to_owned() + &amp;req.name + " V2"});
   }
}

#[tokio::main(worker_threads = 512)]
async fn main() {
    krpc_common::init_log();
    let server: DemoService = DemoService {
        _db: "我是一个DB数据库".to_string(),
    };
    KrpcServer::build(
        //配置注册中心
        RegisterBuilder::new(
            &amp;format!("127.0.0.1:{}", "2181"),
            "default",
            RegisterType::ZooKeeper,
        ),
        //设置监听端口
        "8081",
    )
    .add_rpc_server(Box::new(server))
    .run()
    .await;
}

</code></pre>
<h3>Client</h3>
<pre><code>//初始化KrpcClient
lazy_static! {
    static ref CLI: KrpcClient = KrpcClient::build(
        //配置注册中心
        RegisterBuilder::new(
            &amp;format!("127.0.0.1:{}", "2181"),
            "default",
            RegisterType::ZooKeeper,
        )
    );
}

#[derive(Serialize, Deserialize, Default, Debug)]
struct ReqDto {
    name: String,
}

#[derive(Serialize, Deserialize, Default, Debug)]
struct ResDto {
    res : String,
}

struct DemoService;
//声明Rpc接口
krpc_client! {
   CLI,
   //设置API包路径
   "org.apache.dubbo.springboot.demo",
   //设置service-name
   DemoService,
   //设置service-versions
   None,
   async fn sayHello(&amp;self,req : String) -&gt; Result&lt;String&gt;
   async fn sayHelloV2(&amp;self,req : ReqDto) -&gt; Result&lt;ResDto&gt;
} 

#[tokio::main(worker_threads = 512)]
async fn main() {
    krpc_common::init_log();
    let client = DemoService;
    let res = client.sayHello("world".to_string()).await;
    info!("{:?}",res);
    let res = client.sayHelloV2(ReqDto{name:"world".to_string()}).await;
    info!("{:?}",res);
}
</code></pre>
<h3>Dubbo3</h3>
<p>本项目同时兼容dubbo3协议，可以很方便的与Java版本的Dubbo3项目通过接口暴露的方式进行服务注册发现和互调。</p>
<p>Rust的Server和Client完全不用改造就如上示例即可。</p>
<p>Java版本的Dubbo3项目，代码层面不需要改造，只需要添加一些依赖和配置（因Dubbo3使用接口暴露的方式默认不支持json序列化协议，而是采用fastjson2的二进制序列化格式，所以这里我们需手动添加fastjson1的支持）</p>
<p>这里我们使用duboo3的官方示例dubbo-samples-spring-boot项目进行演示
https://github.com/apache/dubbo-samples</p>
<p>首先我们需要把Server和Client的服务的pom.xml都添加fastjson1的maven依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
    &lt;artifactId&gt;dubbo-serialization-fastjson&lt;/artifactId&gt;
    &lt;version&gt;2.7.23&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3>Java-Server</h3>
<pre><code>@DubboService
public class DemoServiceImpl implements DemoService {

    @Override
    public String sayHello(String name) {
        return "Hello " + name;
    }
}
</code></pre>
<h3>Server-application.yml</h3>
<pre><code>dubbo:
  application:
    name: dubbo-springboot-demo-provider
  protocol:
    name: tri
    port: 50052
    //添加fastjson的支持
    prefer-serialization: fastjson
  registry:
    address: zookeeper://${zookeeper.address:127.0.0.1}:2181
</code></pre>
<h3>Java-Client</h3>
<pre><code>@Component
public class Task implements CommandLineRunner {
    @DubboReference
    private DemoService demoService;

    @Override
    public void run(String... args) throws Exception {
        String result = demoService.sayHello("world");
        System.out.println("Receive result ======&gt; " + result);

        new Thread(()-&gt; {
            while (true) {
                try {
                    Thread.sleep(1000);
                    System.out.println(new Date() + " Receive result ======&gt; " + demoService.sayHello("world"));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    Thread.currentThread().interrupt();
                }
            }
        }).start();
    }
}
</code></pre>
<h3>Client-application.yml</h3>
<pre><code>dubbo:
  application:
    name: dubbo-springboot-demo-consumer
  registry:
    address: zookeeper://${zookeeper.address:127.0.0.1}:2181
</code></pre>
2024-02-22T18:27:43.619563729+08:00 - 文章标题：【Rust日报】2024-02-19 Linux 内核准备升级至 Rust 1.77
2024-02-22T18:27:43.619616680+08:00 - 文章内容：<h1>Linux 内核准备升级至 Rust 1.77</h1>
<p>Linux 6.8 内核已经升级至 Rust 1.75，而最新的补丁则将内核的 Rust 代码迁移到 Rust 1.76，并准备好迎接即将发布的 Rust 1.77。
Rust 1.77 稳定了内核 Rust 代码使用的单字段 "offset_of" 功能，并添加了一个"--check-cfg" 选项，内核 Rust 代码未来可能会过渡到这个选项。这符合 Rust for Linux 跟踪上游 Rust 版本升级的政策，直到确定了所有使用的功能都被认为是稳定的最低版本为止。预计将在即将到来的 Linux 6.9 内核合并窗口中进行对 Rust 1.77 的升级。</p>
<p><a href="https://www.phoronix.com/news/Linux-Kernel-To-Rust-1.77" rel="noopener noreferrer">原文链接</a></p>
<h1>极小的 Rust 二进制文件</h1>
<p>本文探索如何制作一个极小的 x86_64 Linux Rust 二进制文件，并比较其与纯汇编程序的竞争性。</p>
<p>从一个大小为 <code>3.6 MiB</code> 的起点开始，通过优化和调整，逐步减小二进制文件的大小。优化手段包括去除符号、调整编译参数、替换标准库等。通过去除标准库并直接使用 libc，以及自定义 _start 函数，极大地减小了二进制文件的大小。最终通过调整链接器标志和移除不必要的 ELF sections，将二进制文件的大小降至 <code>400 bytes</code>，达到了极小化的目标。</p>
<p>Rust 展现出了出色的系统编程能力，即使在 no_std 环境下也能进行嵌入式编程和其他应用领域。Rust 在性能和体积上的优势使其在实际应用中具有广泛的潜力，甚至可以取代一些汇编编写的程序。</p>
<p><a href="https://darkcoding.net/software/a-very-small-rust-binary-indeed/" rel="noopener noreferrer">原文链接</a></p>
<h1><code>FuturesUnordered</code> 以及 future的顺序</h1>
<p><strong>FuturesUnordered</strong> 是 Rust 中用于并发子任务的强大工具，但如果使用不当，会导致死锁。</p>
<h3>两种常见的 FuturesUnordered 使用模式：</h3>
<ul>
<li><strong>缓冲流</strong>：将工作流表示为 futures 的流，并使用类似 <code>buffered</code> 适配器将其缓冲。</li>
<li><strong>范围任务</strong>：将工作表示为“在” FuturesUnordered 上“生成”的任务，使用类似 <code>moro</code> 库的 API。</li>
</ul>
<h3>死锁的条件：</h3>
<ul>
<li><strong>互斥</strong>：每个任务都需要独占资源。</li>
<li><strong>等待资源</strong>：任务在等待其他资源时持有已分配的资源。</li>
<li><strong>不可抢占</strong>：资源不能从持有者手中强制移除。</li>
<li><strong>循环等待</strong>：存在任务链，每个任务都请求链中下一个任务持有的资源。</li>
</ul>
<h3>示例死锁：</h3>
<p>使用异步生成器和互斥锁。</p>
<pre><code>async gen {
    let mut guard = mutex.lock().await;
    yield x;
    yield y;
    drop(guard);
};

for await elem in iter {
    let mut guard = mutex.lock().await;
    println!("{}", elem);
    drop(guard);
}
</code></pre>
<h3>预防死锁：</h3>
<ul>
<li>通过显式声明并发性来避免控制流中的隐式共享资源。</li>
<li>优先使用范围任务而不是缓冲流，因为它们使资源依赖关系更清晰。</li>
<li>使用通道时要注意队列大小和循环依赖关系。</li>
<li>使用未缓冲通道测试以捕获潜在死锁。</li>
</ul>
<h3>Rust 的优势：</h3>
<ul>
<li>所有权和借用可以防止死锁和复杂的同步。</li>
<li>范围任务应该集成到运行时中以获得更好的借用支持。</li>
</ul>
<h3>其他注意事项：</h3>
<ul>
<li>文章批评了使用大量任意值作为通道大小的做法，因为它隐藏了潜在的死锁。</li>
<li>它建议使用利用所有权和借用的模式。</li>
</ul>
<h2>总结</h2>
<p>FuturesUnordered 是一个强大的工具，但需要谨慎使用以避免死锁。了解死锁的条件以及如何预防它们，并选择合适的模式来实现并发。Rust 的所有权和借用系统可以帮助防止死锁，并使代码更安全、更可靠。</p>
<p><a href="https://without.boats/blog/futures-unordered/" rel="noopener noreferrer">原文链接</a></p>
<h1>Inlyne: 无浏览器 markdown 预览工具</h1>
<p>Inlyne 是一款利用 GPU 加速的无浏览器工具，帮助您快速查看 Markdown 文件. 目前 0.4 版本发布.</p>
<p><img src="https://raw.githubusercontent.com/trimental/inlyne/v0.4/assets/img/example.png" alt="img"></p>
<p><a href="https://github.com/trimental/inlyne/releases/tag/v0.4.0" rel="noopener noreferrer">原文链接</a></p>
<p>--</p>
<p>From 日报小组 BobQ, FBI小白</p>
<p>社区学习交流平台订阅：</p>
<ul>
<li><a href="https://rustcc.cn/" rel="noopener noreferrer">Rustcc论坛: 支持rss</a></li>
<li><a href="https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" rel="noopener noreferrer">微信公众号：Rust语言中文社区</a></li>
</ul>
2024-02-22T18:27:43.619650128+08:00 - 文章标题：报名倒计时！首期自动驾驶OS开发中阶训练营
2024-02-22T18:27:43.619662582+08:00 - 文章内容：<p>国家智能网联汽车创新中心2024首期中阶训练营开始报名啦！</p>
<p>训练营是国家智能网联汽车创新中心发起的技术培训项目，旨在为在校大学生和智能汽车领域工作人员提供专业的自动驾驶操作系统开发技能和知识。培训课程涵盖三个阶段，初阶实现驱动开发，中阶完成OS移植适配，终阶面向自动驾驶场景应用。</p>
<p>本次中阶训练营历时约8周，涵盖了操作系统原理、目标硬件平台、内核移植、系统调优、项目实战等内容，优秀学员更有机会入职国家智能网联汽车创新中心及其合作单位。训练营全程开源免费。</p>
<p>欢迎感兴趣的朋友访问如下网址了解详情并参加报名！
https://mp.weixin.qq.com/s/QA7Z6i7Ax5dN9hrvZDi4nA</p>
2024-02-22T18:27:43.619669974+08:00 - 文章标题：Ferroc：一个无锁、可移植的堆内存分配器
2024-02-22T18:27:43.619697992+08:00 - 文章内容：<p>Ferroc（由“ferrum”和“malloc”组合而成）是一个用Rust编写的无锁、可移植的堆内存分配器，主要参考了<a href="https://github.com/microsoft/mimalloc" rel="noopener noreferrer">mimalloc</a>。</p>
<p>这个内存分配器的设计目标是性能打平目前各种主流的内存分配器（如mimalloc，tcmalloc等），同时提供多种多样的自定义配置以移植到各种环境，比如裸机、嵌入式平台等。</p>
<p>目前已经在crates.io上发布。</p>
<h2>示例</h2>
<p>最简单的用途是作为全局内存分配器：</p>
<pre><code>use ferroc::Ferroc;

#[global_allocator]
static FERROC: Ferroc = Ferroc;

fn main() {
    // Using the global allocator API.
    let _vec = vec![10; 100];

    // Manually allocate memory.
    let layout = std::alloc::Layout::new::&lt;u8&gt;();
    let ptr = Ferroc.allocate(layout).unwrap();
    unsafe { Ferroc.deallocate(ptr, layout) };

    // Immediately run some delayed clean-up operations.
    Ferroc.collect(/* force */false);
}
</code></pre>
<p>如果想要一些自定义配置，比如从mmap系统调用获取新内存还是仅分配静态内存，则可以使用<code>config!</code>系列宏：</p>
<pre><code>// This is the capacity of the necessary additional static
// memory space used by ferroc as the metadata storage.
const HEADER_CAP: usize = 4096;
ferroc::config!(pub Custom =&gt; ferroc::base::Static::&lt;HEADER_CAP&gt;);

#[global_allocator]
static CUSTOM: Custom = Custom;

// Multiple manageable static memory chunks can be loaded at runtime.
let chunk = unsafe { Chunk::from_static(/* ... */) };
CUSTOM.manage(chunk);

// ...And you can start allocation.
let _vec = vec![10; 100];
</code></pre>
<p><code>config!</code>系列宏配置出的分配器默认是带着TLS变量的。如果条件不允许，或者想要更多的自定义空间，可以直接使用内部的结构体（<code>Arenas</code>、<code>Context</code>、<code>Heap</code>）：</p>
<pre><code>ferroc = {version = "*", default-features = false, features = ["base-mmap"]}
</code></pre>
<pre><code>#![feature(allocator_api)]
use ferroc::{
    arena::Arenas,
    heap::{Heap, Context},
    base::Mmap,
};

fn main() {
    let arenas = Arenas::new(Mmap); // `Arenas` are `Send` &amp; `Sync`...
    let cx = Context::new(&amp;arenas);
    let heap = Heap::new(&amp;cx); // ...while `Context`s and `Heap`s are not.

    // Using the allocator API.
    let mut vec = Vec::new_in(&amp;heap);
    vec.extend([1, 2, 3, 4]);
    assert_eq!(vec.iter().sum::&lt;i32&gt;(), 10);

    // Manually allocate memory.
    let layout = std::alloc::Layout::new::&lt;u8&gt;();
    let ptr = heap.allocate(layout).unwrap();
    unsafe { heap.deallocate(ptr, layout) };

    // Immediately run some delayed clean-up operations.
    heap.collect(/* force */false);
}
</code></pre>
<h2>Cargo功能列表</h2>
<ul>
<li>基本功能包含公开的结构体<code>Arenas</code>, <code>Context</code>和<code>Heap</code>；</li>
<li><code>"stat"</code>：统计内存分配数据；</li>
<li><code>"base-static"</code>：默认的静态内存基础分配器<code>Static</code>;</li>
<li><code>"base-mmap"</code>：使用OS自带的虚拟内存系列函数来获取新内存的基础分配器<code>Mmap</code>（依赖<code>std</code>）；</li>
<li><code>"global"</code>：<code>config!</code>和<code>config_mod!</code>等配置宏（自带的TLS变量默认会被泄露）；</li>
<li><code>"libc"</code>: <code>libc</code>依赖项（被<code>config!</code>系列宏的<code>pthread</code>选项依赖，目的是使用pthread的TLS变量析构器来析构<code>config!</code>生成的TLS变量）；</li>
<li><code>"default"</code>：默认的<code>Ferroc</code>分配器，基于<code>Mmap</code>和<code>pthread</code>选项（包括以上所有feature）；</li>
<li><code>"c"</code>：生成<code>fe_malloc</code>等C系列函数和一个C/C++头文件<code>"ferroc.h"</code>，并且如果编译时指定了<code>--cfg sys_alloc</code>会替换掉默认的<code>malloc</code>系列函数；</li>
<li><code>"track-valgrind"</code>：基于<a href="https://github.com/2dav/crabgrind" rel="noopener noreferrer"><code>crabgrind</code></a>的Valgrind内存跟踪检查器.</li>
</ul>
<h2>基准测试</h2>
<p>基准测试使用<a href="https://github.com/daanx/mimalloc-bench" rel="noopener noreferrer"><code>mimalloc-bench</code></a>的一部分子集。在我的16GB内存和Intel i7-10750H CPU @ 2.60GHz处理器的笔记本电脑上运行。</p>
<p>花费时间：
<img src="https://github.com/js2xxx/ferroc/blob/master/assets/time.png?raw=true" alt="Time consumed"></p>
<p>内存占用：
<img src="https://github.com/js2xxx/ferroc/blob/master/assets/memory.png?raw=true" alt="Memory consumed"></p>
<h2>缺点</h2>
<p>目前仅支持最新的Nightly通道的Rust编译器，并且<code>malloc-bench</code>中其他的一部分测试还尚未跑通。</p>
<h3>许可证</h3>
<p>MIT OR Apache-2.0</p>
2024-02-22T18:27:43.619710445+08:00 - 文章标题：Lightning Network Development Recruitment
2024-02-22T18:27:43.619720467+08:00 - 文章内容：<p>responsibilities</p>
<p>As an Open Source RGB/Lightning Developer, you will be a part of the team that contributes to the development of the RGB protocol for assets on top of Bitcoin and the Lightning Network, aimed at building a new ecosystem of Bitcoin based decentralized financial applications. This includes:</p>
<ul>
<li>Contributing to improve and evolve the code functional to the RGB protocol.</li>
<li>Development and maintenance of libraries to facilitate RGB integration for wallet developers.</li>
<li>Development and maintenance of an RGB compatible Bitcoin wallet.</li>
<li>Development and maintenance of Lightning Network and DEX compatible applications.
requirements</li>
<li>Knowledgeable about Bitcoin, Lightning Network and related applications.</li>
<li>Knowledgeable about Rust, Docker and Linux
Work experience: Rust &gt; 2 years, able to provide personal github address.</li>
</ul>
<p>Salary：4000-7000USD/month
Telegram:@C89043</p>
2024-02-22T18:27:43.619727295+08:00 - 文章标题：Rust登陆【华为鸿蒙】操作系统之Native模块开发
2024-02-22T18:27:43.621307959+08:00 - 文章内容：<h1><code>Rust</code>登陆【华为鸿蒙】操作系统之<code>Native</code>模块开发</h1>
<h2>名词解释</h2>
<ul>
<li>【鸿蒙操作系统】的英文全名是<code>Open Harmony Operation System</code>。正文将以其首字母缩写词<code>ohos</code>引用该词条。</li>
<li>【鸿蒙软件开发工具包】的英文全名是<code>Open Harmony Software Development Kit</code>。正文也将以它的首字母缩写词<code>ohsdk</code>引用该词条。</li>
<li><code>DevEco Studio IDE</code>是【华为】为鸿蒙应用程序开发免费提供的集成开发环境。它的最新稳定版内置了<code>ohsdk 3.1.0 (API v9)</code>。</li>
<li>【<code>Native</code>模块】是指由遵循了<code>ArkTs NAPI</code>接口规范的<code>C/Cpp/Rust</code>程序经交叉编译输出的链接库<code>.so</code>文件。</li>
</ul>
<h2>前言</h2>
<p>到写文章时止，虽然华为技术团队既未将<code>rustup</code>工具链无缝集成入<code>DevEco Studio IDE</code>也未提供<code>ArkTs + Rust</code>的“一站式”混合编程体验，但<code>Rust</code>登陆<code>ohos</code>依旧势不可挡，因为相较于<code>Rust</code>带来的生产效率收益（参照<code>c / cpp</code>），搭建交叉编译环境的人工成本真的微不足道。甚至，求助于【操作系统镜像】或<code>Docker</code>技术，@Rustacean 还能避免这类重复性劳动的再次发生。</p>
<p>为了填补<code>DevEco Studio IDE</code>与<code>rustup</code>工具链之间的“窄沟”，仅有两步操作需被执行：</p>
<ol>
<li>搭建面向<code>ohos</code>的交叉编译环境。
<ul>
<li>限于作者<code>dev box</code>是<code>Windows 11</code>，所以本篇文章仅分享从<code>Windows</code>至<code>ohos</code>的交叉编译环境搭建心得。</li>
</ul>
</li>
<li>将交叉编译输出的<code>.so</code>文件注入<code>DevEco Studio</code>工作流。</li>
</ol>
<h2>搭建<code>Windows</code>  ➞ <code>ohos</code>交叉编译环境</h2>
<p>鉴于华为硬件产品的三款主流<code>CPU</code>架构，@Rustacean 需同时准备三套交叉编译方案，分别是：</p>
<ul>
<li>面向<code>64</code>位<code>ARM CPU</code>的<code>aarch64-unknown-linux-ohos</code>方案。</li>
<li>面向<code>32</code>位<code>ARM CPU</code>的<code>armv7-unknown-linux-ohos</code>方案。</li>
<li>面向<code>64</code>位<code>AMD / Intel CPU</code>的<code>x86_64-unknown-linux-ohos</code>方案。</li>
</ul>
<p>前两套方案是为【真机】设备提供动态链接库/<code>Native</code>模块；而后一套方案则是服务于手机模拟器（虚拟机）的。</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/5efb6ea0-5f89-42d1-8654-bf9ee712e84e" alt="image"></p>
<p>上表中<code>Triple</code>的信息描述格式统一是：</p>
<pre><code>&lt;CPU架构&gt;&lt;CPU子架构&gt;-&lt;厂商&gt;-&lt;操作系统&gt;-&lt;应用程序二进制接口格式&gt;
</code></pre>
<p>于是，<code>armv7-unknown-linux-ohos</code>应被读作</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/accaeb68-59f6-4409-90f4-a6826250fdfe" alt="image"></p>
<p>【厂商】栏的<code>unkown</code>是<code>Mozilla</code>公司的“锅”，而不是我定的。就我本意，这一栏馁馁的是汉语拼音<code>HuaWei</code>。</p>
<p>下面上干货了...</p>
<h3>第一步，给<code>ohsdk</code>补装<code>native</code>组件</h3>
<p><code>DevEco Studio IDE</code>的内置<code>ohsdk</code>位于<code>%LocalAppData%\Huawei\Sdk\openharmony\&lt;API 版本号&gt;</code>目录下，但其初始安装却缺失了<code>native</code>组件（— 可能是因为这个模块太大了，超过<code>2GB</code>）。所以，@Rustacean 需要</p>
<ol>
<li>补装<code>native</code>组件</li>
<li>记住<code>ohsdk</code>对应的【<code>API</code>版本号】，因为后续配置得用。</li>
</ol>
<h4>具体步骤</h4>
<ol>
<li>
<p>打开<code>DevEco Studio IDE</code></p>
</li>
<li>
<p>若出现的是【欢迎界面】，就从菜单<code>Configure</code> ➞ <code>Settings</code>，打开<code>Settings</code>对话框</p>
</li>
<li>
<p>若出现的是【工程界面】，就从菜单<code>File</code> ➞ <code>Settings</code>，打开<code>Settings</code>对话框</p>
</li>
<li>
<p>从对话框左侧选择<code>SDK</code>；从右侧查看<code>Platform</code>选项卡下面的内容</p>
</li>
<li>
<p>寻找并记忆被勾选的【<code>SDK</code>版本号 (<code>API</code>版本号)】。比如，下图中的<code>3.1.0 (API 9)</code>。</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/97a34762-1dd0-49d2-b7bf-3b3ee4179611" alt="image"></p>
</li>
<li>
<p>勾选<code>native</code>复选框</p>
</li>
<li>
<p>点击<code>OK</code>按钮</p>
</li>
<li>
<p>等待<code>native</code>组件安装完成 — 耐心点儿，等待时间可不短</p>
</li>
</ol>
<p>待上述操作都正常完成之后，便可见如下所示的新目录结构</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/e7cb9374-fb99-4302-87ef-5dcc37764226" alt="image"></p>
<h3>第二步，重新编译<code>Rust</code>标准库</h3>
<p>之所以把事情搞这么大是因为<code>Mozilla</code>厂方并没有为<code>ohos</code>提供<strong>预编译</strong>的【标准库】二进制文件。于是，尽管<code>ohos</code>已被纳入了<code>rustc</code>交叉编译支持清单（请见下图）</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/b9759f8e-74ed-4c01-816d-18b1485123b5" alt="image"></p>
<p>，但直接执行交叉编译指令</p>
<pre><code>cargo build --release --target=aarch64-unknown-linux-ohos
</code></pre>
<p>还是会遭遇失败和看到<code>E0463</code>号错误</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/46f21f43-13f0-40de-85f5-b562e27c5fc7" alt="image"></p>
<h4>技术方案选型</h4>
<p>编译【标准库】源码有两条技术路径</p>
<ol>
<li>
<p>重新编译整条<code>rustup</code>工具链，捎带着也就编译出【标准库】了 — 难！我没搞定</p>
</li>
<li>
<p>将【标准库】作为<strong>普通</strong>依赖<code>crate</code>和<code>Cargo (Lib) Package</code>工程的业务代码一起编译（— 注：这个解释并不精确，因为细究起来<strong>主</strong><code>crate</code>与<strong>依赖</strong><code>crates</code>是搅和在一起的各自独立编译，而不是绝对意义上的“一锅烩”）。下图中被红框圈定的<code>crates</code>就都出自于【标准库】</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/88cfafee-2836-40b4-a82b-c566a174cb84" alt="image"></p>
</li>
</ol>
<p>我选择了<strong>第二条</strong>技术路线。虽然后一条技术路线拖长了程序编译的总用时，但它仅会影响<strong>首次</strong>编译操作。从那以后，借助<a href="https://github.com/mozilla/sccache?tab=readme-ov-file#sccache---shared-compilation-cache" rel="noopener noreferrer">sccache</a>编译缓存技术，由【标准库】引入的额外延时几乎可以忽略不计。更重要的是，该技术路线不会阻塞 @Rustacean 对<code>rustup</code>工具链的后续升级。咱们随时都可以<code>rustup update</code>。</p>
<h4>采用【方案二】的准备工作与先决条件</h4>
<ol>
<li>
<p>给<code>rustup</code>工具链，补装【标准库】源码（即，<code>rust-src</code>组件）。</p>
<p>从命令行，立即执行且仅执行一次：</p>
<pre><code>rustup component add rust-src
</code></pre>
</li>
<li>
<p>启用<code>nigtly</code>工具链，因为工具链的<code>stable</code>版本还尚不支持“裹挟【标准库】共同编译”的新功能。</p>
<p>从命令行，立即执行且仅执行一次：</p>
<pre><code>rustup default nightly
</code></pre>
</li>
<li>
<p>采用<code>ohsdk</code>内置的<code>llvm - clang</code>作为<code>rustc</code>链接器（下一节将详细介绍）</p>
</li>
<li>
<p>向交叉编译指令添加新命令行参数<code>-Zbuild-std</code>。</p>
<ol>
<li>
<p><code>cargo</code>会透传该参数给<code>rustc</code>并指示编译器不是寻找现成的【标准库】链接文件而是<strong>现场</strong>编译【标准库】源码。</p>
</li>
<li>
<p>编译指令也将变为</p>
<pre><code>cargo +nightly build -Zbuild-std --release --target=aarch64-unknown-linux-ohos
</code></pre>
</li>
</ol>
</li>
</ol>
<h4>如何把<code>ohsdk</code>内置的<code>llvm - clang</code>作为<code>rustc</code>链接器</h4>
<p><strong>第一步</strong>，回忆之前记下的【鸿蒙<code>API</code>版本号】数字和新建环境变量<code>OHOS_API_V</code>。【推荐】从<code>Cargo</code>全局配置文件<code>%UserProfile%\.cargo\config.toml</code>新建<code>OHOS_API_V</code>环境变量，因为</p>
<ul>
<li>一方面，这可最小化对系统环境的“污染” — 该变量仅对<code>Rust</code>交叉编译有用，没有必要系统级全局可见。</li>
<li>另一方面，它随时可被【会话级】<strong>同名</strong>环境变量短暂复写，方便以后临时变更做试验。</li>
</ul>
<p>打开<code>%UserProfile%\.cargo\config.toml</code>配置文件和添加配置表</p>
<pre><code>[env]
OHOS_API_V = "9"
</code></pre>
<p>【注意】伴随今后<code>ohsdk</code>的<strong>自动</strong>升级，该环境变量的值须被同步地<strong>手动</strong>更新，以避免编译失败。</p>
<p><strong>第二步</strong>，将<code>ohsdk</code>目录下的<code>LLVM</code>前端编译器<code>llvm\bin\clang.exe</code>包装为<code>rustc</code>的【<strong>鸿蒙</strong>链接器】。敲黑板，重点来了！@Rustacean 需分别构建<strong>三个</strong>链接器，以服务<strong>三套</strong>交叉编译方案，和向华为的<strong>三类</strong>硬件设备提供<code>.so</code>文件。于是，有</p>
<ul>
<li>
<p>【链接器1】面向<code>64</code>位<code>ARM CPU</code><strong>真机</strong>的<code>aarch64-unknown-linux-ohos</code>交叉编译方案。在<code>%UserProfile%</code>目录下，新建<code>cmd</code>文件<code>aarch64-unknown-linux-ohos-clang.cmd</code>，并添加如下代码</p>
<pre><code>%LocalAppData%\Huawei\Sdk\openharmony\%OHOS_API_V%\native\llvm\bin\clang.exe ^
-target aarch64-linux-ohos ^
--sysroot=%LocalAppData%\Huawei\Sdk\openharmony\%OHOS_API_V%\native\sysroot ^
-D__MUSL__ %*
</code></pre>
</li>
<li>
<p>【链接器2】面向<code>32</code>位<code>ARM CPU</code><strong>真机</strong>的<code>armv7-unknown-linux-ohos</code>交叉编译方案。在<code>%UserProfile%</code>目录下，新建<code>cmd</code>文件<code>armv7-unknown-linux-ohos-clang.cmd</code>，并添加如下代码</p>
<pre><code>%LocalAppData%\Huawei\Sdk\openharmony\%OHOS_API_V%\native\llvm\bin\clang.exe ^
-target arm-linux-ohos ^
--sysroot=%LocalAppData%\Huawei\Sdk\openharmony\%OHOS_API_V%\native\sysroot ^
-D__MUSL__ ^
-march=armv7-a ^
-mfloat-abi=softfp ^
-mtune=generic-armv7-a ^
-mthumb %*
</code></pre>
</li>
<li>
<p>【链接器3】面向<code>64</code>位<code>AMD / Intel CPU</code><strong>模拟器</strong>的<code>x86_64-unknown-linux-ohos</code>交叉编译方案。在<code>%UserProfile%</code>目录下，新建<code>cmd</code>文件<code>x86_64-unknown-linux-ohos-clang.cmd</code>，并添加如下代码</p>
<pre><code>%LocalAppData%\Huawei\Sdk\openharmony\%OHOS_API_V%\native\llvm\bin\clang.exe ^
-target x86_64-linux-ohos ^
--sysroot=%LocalAppData%\Huawei\Sdk\openharmony\%OHOS_API_V%\native\sysroot ^
-D__MUSL__ %*
</code></pre>
</li>
</ul>
<p><strong>第三步</strong>，全局且有条件地向<code>rustc</code>装配【鸿蒙链接器】。其中，</p>
<ul>
<li>【全局】意味着修改<code>Cargo</code>全局配置文件<code>%UserProfile%\.cargo\config.toml</code>和作用于所有<code>Cargo Package</code>工程。</li>
<li>【有条件】意味着采用<strong>条件编译</strong>语法<code>target.&lt;triple&gt;.linker</code>限定该【链接器】仅生效于面向<code>ohos</code>的交叉编译操作。</li>
</ul>
<p>具体作法，打开<code>%UserProfile%\.cargo\config.toml</code>配置文件和添加配置表</p>
<pre><code>[target.aarch64-unknown-linux-ohos]
linker = "./aarch64-unknown-linux-ohos-clang.cmd"
[target.armv7-unknown-linux-ohos]
linker = "./armv7-unknown-linux-ohos-clang.cmd"
[target.x86_64-unknown-linux-ohos]
linker = "./x86_64-unknown-linux-ohos-clang.cmd"
[profile.dev.package.compiler_builtins]
opt-level = 2
</code></pre>
<p>再对前面配置片段补充两点解释：</p>
<ol>
<li>配置项<code>linker</code>以<strong>相对</strong>路径引用链接器文件的背后逻辑是<code>cargo</code>总是以<code>config.toml</code>的<strong>父文件夹</strong>（.cargo）<strong>所处目录</strong>为起点开始解析<strong>相对</strong>路径（，而不是以<code>config.toml</code>的同级目录为起点）。所以，本例中的<code>./</code>路径前缀对应的就是登录账号的根目录<code>%UserProfile%</code>。</li>
<li>配置项<code>opt-level</code>，借助【<code>Profile</code>重写（i.e. Override）】配置表头<code>[profile.dev.package.compiler_builtins]</code>，仅将【开发编译】模式下【标准库】内<code>compiler_builtins crate</code>的代码优化级别强制锚定于<code>2</code>。否则，<code>cargo build -Zbuild-std --target=aarch64-unknown-linux-ohos</code>指令（注意：没有<code>--release</code>参数）会概率性地失败于<code>exit code: 0xc0000005, STATUS_ACCESS_VIOLATION</code>错误。</li>
</ol>
<p><strong>第四步</strong>，给冗长的交叉编译指令约定（短）别名。</p>
<p>还是打开<code>%UserProfile%\.cargo\config.toml</code>配置文件和增补如下配置表</p>
<pre><code>[alias]
ohos-build = ["build", "-Zbuild-std", "--target=aarch64-unknown-linux-ohos", "--target=armv7-unknown-linux-ohos", "--target=x86_64-unknown-linux-ohos"]
</code></pre>
<p>于是，只要执行<strong>一条</strong><code>cargo ohos-build</code>指令就相当于连续执行下面<strong>三条</strong>编译指令：</p>
<ol>
<li><code>cargo build -Zbuild-std --target=aarch64-unknown-linux-ohos</code></li>
<li><code>cargo build -Zbuild-std --target=armv7-unknown-linux-ohos</code></li>
<li><code>cargo build -Zbuild-std --target=x86_64-unknown-linux-ohos</code></li>
</ol>
<h3>总结交叉编译环境的搭建成果</h3>
<p>以后每次在<code>Cargo (Lib) Package</code>工程根目录下执行</p>
<pre><code>cargo ohos-build --release
</code></pre>
<p>，编译器都会立即</p>
<ol>
<li>唤起<code>ohsdk</code>内置的<code>LLVM</code>前端编译器<code>llvm - clang</code>作为<code>rustc</code>链接器</li>
<li>将【标准库】源码作为<strong>普通</strong>依赖<code>crate</code>与<strong>主</strong><code>crate</code>业务程序一起编译</li>
<li>并行启动三个<code>JOB</code>进程对同一套<code>Rust</code>源码同时执行三组交叉编译操作</li>
<li>交叉编译输出三个<strong>文件名相同</strong>但 <strong><code>ABI</code>格式不同</strong>的动态链接库<code>.so</code>文件</li>
</ol>
<h3>新建<code>Cargo (Library) Package</code>工程，验证交叉编译环境</h3>
<p>首先，克隆<a href="https://github.com/stuartZhang/socket2" rel="noopener noreferrer">stuartZhang/socket2</a>至本地，并将代码分支切至<code>v0.4.x</code>。</p>
<pre><code>git clone git@github.com:stuartZhang/socket2.git
cd socket2
git checkout -q v0.4.x
</code></pre>
<p>关于这一步操作的必要性，我已经详细地阐述于<a href="https://github.com/stuartZhang/node-bindgen?tab=readme-ov-file#ohos-node-bindgen%E8%BF%98%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8" rel="noopener noreferrer">ohos-node-bindgen还不能被直接使用</a>章节了。简单地讲，这是为了绕过<a href="https://crates.io/crates/socket2" rel="noopener noreferrer">socket2 crate</a>对华为鸿蒙操作系统的<strong>不兼容</strong>缺陷。</p>
<p>然后，从命令行，新建<code>Cargo (Library) Package</code>工程</p>
<pre><code>cd ..
cargo new --lib calculator
code calculator
</code></pre>
<p>其次，在<code>VSCode</code>内，打开<code>Cargo.toml</code>文件，和追加如下内容</p>
<pre><code>[lib]
crate-type = ["cdylib"]

[dependencies]
ohos-node-bindgen = "6.0.3"
socket2 = "0.4.10"

[patch.crates-io]
socket2 = { path = "../socket2" }
</code></pre>
<p>前面配置片段内的【依赖图重写】配置表<code>[patch.crates-io]</code>指示<code>Cargo</code>包管理器使用本地的<code>stuartZhang/socket2 crate</code>山寨货<strong>替换</strong><code>crates.io</code>上的正品，因为正品<strong>不兼容</strong>华为操作系统。</p>
<p>接着，从<code>VSCode</code>打开<code>src/lib.rs</code>文件，和增补如下<code>Demo</code>代码。这是一段简单的整数加运算程序。<strong>请把注意力聚焦在【派生宏】的使用上</strong>。</p>
<pre><code>use ::ohos_node_bindgen::derive::ohos_node_bindgen;
#[ohos_node_bindgen]
fn add(first: i32, second: i32) -&gt; i32 {
    first + second
}
</code></pre>
<p>再次，执行交叉编译</p>
<pre><code>cargo ohos-build --release
</code></pre>
<p>最后，从【资源管理器】查看编译输出结果</p>
<pre><code>Cargo (Library) Package 工程根目录
├── Cargo.toml
├── src — Rust 源码目录
├── target
│  ├── aarch64-unknown-linux-ohos
│  │  └── release
│  │     └── libcalculator.so
│  ├── armv7-unknown-linux-ohos
│  │  └── release
│  │     └── libcalculator.so
│  ├── x86_64-unknown-linux-ohos
│  │  └── release
│  │     └── libcalculator.so
</code></pre>
<p>值得注意的是，编译输出的链接库文件名是<strong>有<code>lib</code>前缀</strong>的。所以，<code>Native</code>模块的文件名是<code>lib&lt;包名&gt;.so</code>，而不是<code>&lt;包名&gt;.so</code>。</p>
<h2>将<code>Native</code>模块注入普通的<code>DevEco Studio</code>工程</h2>
<blockquote>
<p><code>Native</code>模块就是由前面交叉编译输出的<code>ArkTs N-API</code>链接库<code>.so</code>文件。</p>
</blockquote>
<p>首先，从<code>DevEco Studio IDE</code>新建/打开普通<code>Empty Ability</code>工程。</p>
<p>然后，修改<strong>模块级</strong>的<code>build-profile.json5</code>文件（比如，<code>entry/build-profile.json5</code>），和添加如下配置项至<code>buildOption</code>节点</p>
<pre><code>"externalNativeOptions": {
  "abiFilters": [
    "arm64-v8a",
    "armeabi-v7a",
    "x86_64"
  ]
}
</code></pre>
<p>其次，在模块根目录下，创建下面三个子文件夹</p>
<ul>
<li><code>libs/arm64-v8a</code></li>
<li><code>libs/armeabi-v7a</code></li>
<li><code>libs/x86_64</code></li>
</ul>
<p>接着，依次向它们复制入编译好的链接库文件。例如，</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/a003500d-9f39-4855-8cbd-3e60b8d05a08" alt="image"></p>
<p>最后，在<code>ArkTs</code>业务代码内（比如，<code>entry/src/main/ets/pages/Index.ets</code>），以<code>ES Module</code>语法，导入<code>Native</code>模块，和调用其成员方法</p>
<pre><code>import calculator from 'libcalculator.so';
const result = calculator.add(2, 3);
</code></pre>
<p>总的来讲，调用端的<code>ets</code>代码就这么简单！但还是有三处优化可做以改善开发体验：</p>
<h3>优化<code>DevEco Studio</code>工程目录结构</h3>
<p>将<code>Cargo (Lib) Package</code>与<code>DevEco Studio Project</code>合并为一个工程更有利于提高<code>Rust + ArkTs</code>的混合编程生产力。所以，如下<code>DevEco Studio</code>工程目录结构是被强力推荐的：</p>
<pre><code>DevEco Studio 工程根目录
├── entry — 模块根目录
│   ├── libs — 交叉编译输出的 .so 文件都被复制到下面的子文件夹内
│   │   ├── arm64-v8a
│   │   ├── armeabi-v7a
│   │   └── x86_64
│   ├── src
│   │   ├── main
│   │   │  ├── resources
│   │   │  ├── cpp  — *旧有*的 Cpp(ArkTs N-API) 工程目录
│   │   │  ├── ets  — *旧有*的 ArkTs 源码目录
│   │   │  ├── rust — *新建*的 Rust(ArkTs N-API) 工程目录
│   │   │  │   ├── Cargo.toml
│   │   │  │   ├── src — Rust 源码目录
│   │   │  │   ├── target
│   │   │  │   │  ├── aarch64-unknown-linux-ohos
│   │   │  │   │  │  └── release
│   │   │  │   │  ├── armv7-unknown-linux-ohos
│   │   │  │   │  │  └── release
│   │   │  │   │  ├── x86_64-unknown-linux-ohos
│   │   │  │   │  │  └── release
</code></pre>
<p>将<code>Cargo (Lib) Package</code><strong>降级为</strong><code>DevEco Studio Project</code>内某个特定模块下的<strong>子工程</strong>有两个好处：</p>
<ol>
<li>同一个<code>DevEco Studio</code>工程内可同时包含<strong>多个</strong><code>Native</code>子工程。</li>
<li>每个<code>Native</code>子工程既可<strong>独占</strong>一个模块以达成与主模块业务代码<strong>有限隔离</strong>的目的，也能与<code>ets</code>程序“混住”耦合于相同模块内。</li>
</ol>
<h4>友情提示</h4>
<p>在移动<code>Cargo (Lib) Package</code>工程位置后，千万别忘了同步修改<code>Cargo.toml</code>配置文件中【依赖图重写】配置表<code>[patch.crates-io]</code>对本地<code>stuartZhang/socket2 crate</code>的引用路径。否则，会编译失败！</p>
<p>若假设<code>stuartZhang/socket2 crate</code>与<code>DevEco Studio Project</code>处理于平级目录，那么【依赖图重写】配置表应该改为</p>
<pre><code>[patch.crates-io]
socket2 = { path = "../../../../../socket2" }
</code></pre>
<h3>自动化链接库<code>.so</code>文件的复制操作</h3>
<p>在每次执行<code>cargo ohos-build --release</code>指令之后都徒手复制三个<code>.so</code>文件至不同的文件夹是非常低效的，所以 @Rustacean 有必要给<code>Cargo</code>编写<code>build.rs</code>与<code>post_build.rs</code>构建程序，以扩展包管理器在<strong>编译前</strong>与<strong>编译后</strong>的处理行为，并自动完成文件复制操作。其中，</p>
<ol>
<li><a href="https://github.com/stuartZhang/Arkts-NAPI-Rust-Demo/blob/main/entry/src/main/rust/build.rs" rel="noopener noreferrer">build.rs</a>作为【前置处理】程序
<ol>
<li>从环境变量，收集<code>.so</code>文件的位置信息</li>
<li>生成<code>[CMD] COPY /Y</code>或<code>[Shell] cp -f</code>文件复制指令</li>
<li>将【文件复制】指令尾追加至同一个<code>.cmd / .sh</code>脚本文件</li>
</ol>
</li>
<li><a href="https://github.com/stuartZhang/Arkts-NAPI-Rust-Demo/blob/main/entry/src/main/rust/post_build.rs" rel="noopener noreferrer">post_build.rs</a>作为【后置处理】程序
<ol>
<li>执行被写入【文件复制】指令的程序文件，并</li>
<li>删除该程序文件</li>
</ol>
</li>
</ol>
<blockquote>
<p>【打广告】<code>build.rs</code>与<code>post_build.rs</code>皆未对上下文做任何的假设。所以，它们可被<strong>零成本</strong>地复用于其它同类工程中。</p>
</blockquote>
<p>还是看图吧，一图抵千词</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/891e6a5d-cbfd-453d-b374-c221dc83a186" alt="image"></p>
<p>设计很完美但现实很骨感，因为<code>Mozilla</code>厂方的<code>rustup</code>工具链尚<strong>不</strong>支持【后置处理】。所以，@Rustacean 需</p>
<ol>
<li>
<p>额外安装功能增补包<a href="https://crates.io/crates/cargo-post" rel="noopener noreferrer">cargo-post</a></p>
<pre><code>cargo install cargo-post
</code></pre>
</li>
<li>
<p>修改<code>Cargo</code>全局配置文件<code>%UserProfile%\.cargo\config.toml</code>中的<code>ohos-build</code>别名设置，以使<code>cargo-post</code>生效</p>
<pre><code>[alias]
ohos-build = ["post", "build", "-Zbuild-std", "--target=aarch64-unknown-linux-ohos", "--target=armv7-unknown-linux-ohos", "--target=x86_64-unknown-linux-ohos"]
</code></pre>
<p>【注意】在"build"左侧<strong>新</strong>添加了"post"数组项</p>
</li>
</ol>
<h3>给<code>Native</code>模块导出接口，添加<code>.d.ts</code>类型提示</h3>
<p><code>DevEco Studio IDE</code>并没有集成类似于<a href="https://www.nirsoft.net/utils/dll_export_viewer.html" rel="noopener noreferrer">DLL Export Viewer</a>的【动态链接库外部接口反射工具】。所以需要</p>
<ol>
<li>@Rustacean 在输出<code>.so</code>文件的同时也提供一份接口类型说明的<code>.d.ts</code>文件（— 其功能几乎等效于<code>C</code>头文件），并</li>
<li>将该类型说明文件注入<code>DevEco Studio</code>工作流</li>
</ol>
<p>接下来，我沿着前面<code>Rust + ArkTs</code>混合编程的<strong>新</strong>目录结构，描述操作步骤：</p>
<ol>
<li>
<p>在模块<code>entry</code>的根目录下，创建<code>src/main/rust/types/libcalculator</code>子目录。注意：路径末端的文件夹名<code>libcalculator</code>是链接库文件的<code>basename</code>。</p>
</li>
<li>
<p>在新建文件夹内，再新建文件<code>index.d.ts</code>和添入<code>Native</code>模块导出函数的函数签名</p>
<pre><code>export const add: (frist: number, second: number) =&gt; number;
</code></pre>
</li>
<li>
<p>接着新建文件<code>oh-package.json5</code>和添入<code>Native</code>模块的摘要信息。</p>
<pre><code>{
    "name": "libcalculator.so",
    "types": "./index.d.ts",
    "version": "0.1.0",
    "description": "ArkTs NAPI 原生模块示例"
}
</code></pre>
<p>其中，</p>
<ol>
<li><code>name</code>字段就是链接库的文件名（含扩展名）。</li>
<li><code>types</code>字段是指向类型说明文件的<strong>相对</strong>路径。</li>
<li><code>version</code>字段是<code>Native</code>模块版本号。【推荐】该字段值与<code>Cargo (Lib) Package</code>子工程中<code>Cargo.toml</code>配置文件内<code>[package]</code>配置表下<code>version</code>配置项的值保持一致 — 这又是一处纯人工同步点。</li>
<li><code>description</code>字段是<code>Native</code>模块描述信息。</li>
</ol>
</li>
<li>
<p>打开<code>entry</code>模块的<code>oh-package.json5</code>文件，并添加对<code>Native</code>模块的依赖项条目。</p>
<pre><code>"dependencies": {
    "libcalculator.so": "file:src/main/rust/types/libcalculator"
}
</code></pre>
<p>在依赖项条目中，左侧是链接库的文件名；而右侧是指向了类型说明文件所处文件夹的相对目录。</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/a2190d96-e493-4ad6-8652-ba6fb8598c74" alt="image"></p>
</li>
<li>
<p>最后，从<code>DevEco Studio IDE</code>依次点击菜单项<code>Build</code> ➞ <code>Rebuild Project</code>重新构建整个工程和使配置项修改生效。</p>
</li>
</ol>
<p>于是，鸿蒙应用软件开发程序员就能在<code>ets</code>与<code>ts</code>代码编辑器内获得针对<code>Native</code>模块<code>API</code>的丰富类型提示了。</p>
<h2>线上例程</h2>
<p>我已将上述全部文字描述内容都例程化到<code>github</code>工程<a href="https://github.com/stuartZhang/Arkts-NAPI-Rust-Demo/tree/main" rel="noopener noreferrer">Arkts-NAPI-Rust-Demo</a>内了。线下运行该工程可加强对文章繁杂内容的理解。</p>
<h3>运行例程工程的环境要求</h3>
<ol>
<li><code>rustc 1.75.0-nightly</code></li>
<li><code>VSCode 1.86</code></li>
<li><code>ohsdk 3.1.0(API v9)</code></li>
<li><code>DevEco Studio 3.1.1 Release</code></li>
</ol>
<h3>运行例程工程的具体步骤</h3>
<ol>
<li>
<p>克隆<code>git@github.com:stuartZhang/Arkts-NAPI-Rust-Demo.git</code></p>
</li>
<li>
<p>在<code>VSCode</code>内，</p>
<ol>
<li>打开<code>entry/src/main/rust</code>目录</li>
<li>敲击<code>Alt + T + R</code>键。</li>
<li>从<code>Command Palette</code>下拉列表，依次点击<code>build</code> ➞ <code>ohos-build</code> ➞ <code>--release</code></li>
<li>观察控制台输出日志，等待交叉编译结束。</li>
</ol>
</li>
<li>
<p>在<code>DevEco Studio IDE</code>内，</p>
<ol>
<li>打开工程根目录</li>
<li>启动手机模拟器</li>
<li>敲击<code>Shift + F10</code>键，运行移动端程序</li>
</ol>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/b31b49cd-5925-457d-b414-5f43b4c93461" alt="image"></p>
</li>
</ol>
<h2>结束语与扩展阅读</h2>
<p>搞定【交叉编译】难关仅只是鸿蒙<code>Rust</code>原生开发万里征程的<strong>第一步</strong>。加深对<code>ArkTs - NAPI</code>接口定义的理解才是【形成生产力】的核心任务。好消息是</p>
<ol>
<li>
<p><code>ArkTs - NAPI</code>与<code>nodejs N-API</code>高度相似。至少截至目前，它们的相似度还<code>&gt;= 95%</code>。所以，已熟悉<code>nodejs</code>原生模块编程的“老司机”们上手鸿蒙<code>ArkTs - NAPI</code>应该不难。</p>
</li>
<li>
<p>另外，我在春节假期期间贡献的<a href="https://github.com/stuartZhang/node-bindgen?tab=readme-ov-file#ohos-node-bindgen%E8%BF%98%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8" rel="noopener noreferrer">ohos-node-bindgen crate</a>更可<strong>大幅降低</strong><code>ArkTs - NAPI</code>原生开发的复杂度。请对比下图左右侧的代码量</p>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/e94fb366-eb02-42c7-a89c-d1c8835a58a5" alt="image"></p>
<p>所以，<a href="https://github.com/stuartZhang/node-bindgen?tab=readme-ov-file#ohos-node-bindgen%E8%BF%98%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8" rel="noopener noreferrer">ohos-node-bindgen crate</a>值得大家点<code>star</code>呀！也请大家给<a href="https://github.com/stuartZhang/Arkts-NAPI-Rust-Demo/tree/main" rel="noopener noreferrer">Arkts-NAPI-Rust-Demo</a>点<code>star</code>！</p>
</li>
</ol>
<p><img src="https://github.com/rust-lang/cargo/assets/13935927/3ccc7de3-e0cc-4d0d-8a31-2d2ed466e23c" alt="ohos-node-bindgen摘要"></p>
2024-02-22T18:27:43.621417960+08:00 - 文章标题：Tran v.0.1.11 发布了!
2024-02-22T18:27:43.621449460+08:00 - 文章内容：<p><a href="https://github.com/Borber/Tran/releases/tag/v.0.1.11" rel="noopener noreferrer">Release v.0.1.11</a></p>
<p>已发布 <code>v0.1.11</code> 版本！相比一个月前的 <code>v0.1.9</code> 版本 平均反应速度提升至少 <strong>80ms</strong> 主要改进：</p>
<ul>
<li>支持多显示器</li>
<li>去除 Tray 将 退出 功能合并到面板中</li>
<li>设置界面, 按钮 hover 效果</li>
<li>避免多次启动</li>
<li>锁定快捷键, 去除无关的按键模拟, 提升快捷键响应速度</li>
<li>快快快, 快就完了</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/Borber/PublicPic1/tran/v1/tran-exit.png" alt="tran-exit"></p>
<h1>Tran</h1>
<p>简洁, 快速, 划词翻译</p>
<p><a href="https://github.com/Borber/tran?tab=GPL-3.0-1-ov-file" rel="noopener noreferrer"><img src="https://img.shields.io/github/license/borber/tran?color=%2398cbed&amp;logo=rust&amp;style=for-the-badge" alt="LICENSE"></a>
<a href="https://github.com/Borber/tran/releases" rel="noopener noreferrer"><img src="https://img.shields.io/github/downloads/Borber/tran/total.svg?style=for-the-badge&amp;color=82E0AA&amp;logo=github" alt="Downloads"></a>
<a href="https://www.rust-lang.org/" rel="noopener noreferrer"><img src="https://img.shields.io/badge/-Rust-orange?logo=rust&amp;style=for-the-badge&amp;logoColor=white" alt="Rust"></a>
<a href="https://tauri.app/" rel="noopener noreferrer"><img src="https://img.shields.io/badge/Tauri-blue?logo=tauri&amp;color=1B1B1D&amp;style=for-the-badge" alt="Tauri"></a>
<a href="https://github.com/Borber/tran/releases" rel="noopener noreferrer"><img src="https://img.shields.io/badge/-Windows-blue?logo=windows&amp;style=for-the-badge&amp;logoColor=white" alt="Windows"></a>
<a href="https://github.com/Borber/tran/releases" rel="noopener noreferrer"><img src="https://img.shields.io/badge/-macOS-black?&amp;logo=apple&amp;style=for-the-badge&amp;logoColor=white" alt="MacOS"></a>
<a href="https://github.com/Borber/tran/releases" rel="noopener noreferrer"><img src="https://img.shields.io/badge/-Linux-yellow?logo=linux&amp;style=for-the-badge&amp;logoColor=white" alt="Linux"></a></p>
<blockquote>
<p><strong>Keep it simple，stupid.</strong></p>
</blockquote>
<h1>功能</h1>
<table>
<thead>
<tr>
<th align="center">划词翻译</th>
<th align="center">划过固定</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img src="https://fastly.jsdelivr.net/gh/Borber/PublicPic1/tran/v1/translate.gif" alt="translate"></td>
<td align="center"><img src="https://fastly.jsdelivr.net/gh/Borber/PublicPic1/tran/v1/drag.gif" alt="drag"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th align="center">划过关闭</th>
<th align="center">划过复制</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img src="https://fastly.jsdelivr.net/gh/Borber/PublicPic1/tran/v1/close.gif" alt="close"></td>
<td align="center"><img src="https://fastly.jsdelivr.net/gh/Borber/PublicPic1/tran/v1/copy.gif" alt="copy"></td>
</tr>
</tbody>
</table>
<p><strong>快捷键：</strong> <code>Alt + X</code></p>
2024-02-22T18:27:43.621492927+08:00 - 文章标题：smartscp: better scp
2024-02-22T18:27:43.621549151+08:00 - 文章内容：<ul>
<li>对scp的封装, 自动跳过被 gitignore 的文件</li>
<li></li>
<li>原理
- 用 sshfs 把远程目录挂在本地的临时目录
- 用 xcp 复制文件</li>
</ul>
<p>之前我尝试过用 sftp 传输文件, 但是 sftp 很难控制远程 git 仓库
后来我发现 sshfs 可以操控远程 git 仓库像本地一样简单
因此切换到了 sshfs</p>
<ul>
<li>
<p>基本用法</p>
<ul>
<li>和 scp 一样, 不过传目录不需要 -r 参数</li>
<li>
<pre><code>smartscp remote-host:remote_path local_path
smartscp local_path remote-host
smartscp local_path remote-host:remote_path
</code></pre>
</li>
</ul>
</li>
<li>
<ul>
<li>如果目标目录是缺省的, smartscp  会自动根据原目录相对于 home 的偏移量, 计算目标目录
<ul>
<li>比如source 是 ~/foo/bar, 那会自动传到远程的 ~/foo/bar</li>
<li>
<pre><code>smartscp ~/foo/bar remote-host
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li></li>
<li>
<p>使用场景</p>
<ul>
<li>传 rust 项目的时候,避免传 target/</li>
<li>传 nodejs 项目的时候, 避免传 node_modules/</li>
<li>对于带宽 网速有限的网络环境, 特别有用</li>
</ul>
</li>
<li>
<p>尚不支持的功能</p>
<ul>
<li>包含 : 的文件名</li>
</ul>
</li>
<li></li>
<li>
<p>注意</p>
<ul>
<li>不兼容 scp 的参数, 比如不接受 -r 参数</li>
<li>不要直接替代 scp</li>
<li></li>
</ul>
</li>
<li>
<p>Q&amp;A</p>
<ul>
<li>为什么不用 <code>rsync --exclude=</code>
<ul>
<li>我并不觉得方便</li>
<li>不够自动化</li>
<li>要支持复杂的 gitignore</li>
</ul>
</li>
<li>为什么用rust写
- 为了在源码级依赖 xcp</li>
<li>为什么不从头用rust写一遍 scp, 而不是调用 scp
<ul>
<li>需要不少工作量</li>
</ul>
</li>
<li>为什么不用 c 直接改 scp
<ul>
<li>c 中不太方便导库</li>
</ul>
</li>
</ul>
</li>
</ul>
2024-02-22T18:27:43.621594828+08:00 - 文章标题：更快的 tsv 解析
2024-02-22T18:27:43.621683135+08:00 - 文章内容：<ul>
<li><a href="#%E6%9B%B4%E5%BF%AB%E7%9A%84-tsv-%E8%A7%A3%E6%9E%90" rel="noopener noreferrer">更快的 tsv 解析</a>
<ul>
<li><a href="#%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA" rel="noopener noreferrer">项目搭建</a></li>
<li><a href="#regex-%E8%A7%A3%E6%9E%90" rel="noopener noreferrer">regex 解析</a></li>
<li><a href="#%E5%87%8F%E5%B0%91%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D" rel="noopener noreferrer">减少内存分配</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-ascii-%E6%AD%A3%E5%88%99" rel="noopener noreferrer">使用 ascii 正则</a></li>
<li><a href="#%E6%8A%9B%E5%BC%83-regex" rel="noopener noreferrer">抛弃 regex</a></li>
<li><a href="#%E6%89%8B%E5%86%99%E8%A7%A3%E6%9E%90%E7%8A%B6%E6%80%81%E6%9C%BA" rel="noopener noreferrer">手写解析状态机</a></li>
<li><a href="#simd-%E5%8A%A0%E9%80%9F" rel="noopener noreferrer">SIMD 加速?</a></li>
<li><a href="#%E6%80%BB%E7%BB%93" rel="noopener noreferrer">总结</a></li>
</ul>
</li>
</ul>
<p>最近在B站冲浪时发现一个 Rust 和 Go 解析 tsv 文件的视频, 作者需要解析使用 <code>get-NetTCPConnection | Format-Table -Property LocalAddress,LocalPort,RemoteAddress,RemotePort,State,OwningProcess</code> 获取的本地所有 TCP 连接信息, 文件输出大致如下</p>
<pre><code>LocalAddress                          LocalPort RemoteAddress                     RemotePort       State OwningProcess
------------                          --------- -------------                     ----------       ----- -------------
192.168.1.4                               54339 104.210.1.98                             443 Established          4504
</code></pre>
<p>视频作者使用 regex 正则库处理输出, 发现比 Go 版本慢, 优化后虽然比 Go 快, 但并没有领先多少, 于是我自己尝试使用别的优化方法, 解析耗时能优化使用正则解析的 10% 左右. 下面来看看我的优化过程.</p>
<h2>项目搭建</h2>
<p>进行性能时建议使用 <a href="https://github.com/bheisler/criterion.rs" rel="noopener noreferrer">criterion</a>, 它帮我们解决了性能的内存预加载, 操作耗时, 性能记录, 图表输出等功能.</p>
<pre><code>cargo new --lib tsv
cd tsv
cargo add criterion --dev -F html_reports
cargo add regex
</code></pre>
<p>然后在 Cargo.toml 里添加如 bench 文件</p>
<pre><code>[[bench]]
name = "parse"
harness = false
</code></pre>
<pre><code>// benches/parse.rs
#![allow(dead_code)]
use criterion::{black_box, criterion_group, criterion_main, Criterion};

const OUTPUT: &amp;str = include_str!("net.tsv");

fn criterion_benchmark(c: &amp;mut Criterion) {
    todo!()
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
</code></pre>
<p>测试使用的 tsv 一共 380 行.</p>
<h2>regex 解析</h2>
<p>使用正则解析的正则表达式很简单, 这里直接给代码, 为了避免重复编译正则表达式和重新分配内存报错结果列表, 这里将她们作为参数传给解析函数.</p>
<pre><code>struct OwnedRecord {
    local_addr: String,
    local_port: u16,
    remote_addr: String,
    remote_port: u16,
    state: String,
    pid: u64,
}
fn regex_owned(input: &amp;str, re: &amp;regex::Regex, result: &amp;mut Vec&lt;OwnedRecord&gt;) {
    input.lines().for_each(|line| {
        if let Some(item) = re.captures(line).and_then(|captures| {
            let (_, [local_addr, local_port, remote_addr, remote_port, state, pid]) =
                captures.extract();
            let ret = OwnedRecord {
                local_addr: local_addr.to_string(),
                local_port: local_port.parse().ok()?,
                remote_addr: remote_addr.to_string(),
                remote_port: remote_port.parse().ok()?,
                state: state.to_string(),
                pid: pid.parse().ok()?,
            };
            Some(ret)
        }) {
            result.push(item);
        }
    });
    assert_eq!(result.len(), 377);
}
</code></pre>
<p>parse.rs 文件里要加上使用的正则和提前创建好列表, 并且将函数添加的 bench 目标里</p>
<pre><code>fn criterion_benchmark(c: &amp;mut Criterion) {
    let re = regex::Regex::new(r"(\S+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\S+)\s+(\d+)").unwrap();
    let mut r1 = Vec::with_capacity(400);
    c.bench_function("regex_owned", |b| {
        b.iter(|| {
            // 重置输出 vector
            r1.clear();
            regex_owned(black_box(OUTPUT), &amp;re, &amp;mut r1);
        })
    });
}
</code></pre>
<p>接着跑 <code>cargo bench --bench parse</code> 进行测试, 在我的电脑上测得每次运行耗时 450 µs 左右.</p>
<h2>减少内存分配</h2>
<p>一个最简单的优化是使用 <code>&amp;str</code> 以减少每次创建 <code>String</code> 带来的内存分配和数据复制.</p>
<pre><code>struct Record&lt;'a&gt; {
    local_addr: &amp;'a str,
    local_port: u16,
    remote_addr: &amp;'a str,
    remote_port: u16,
    state: &amp;'a str,
    pid: u64,
}
</code></pre>
<p>两个函数代码差不多, 所以这里不再列出来, 可以通过 <a href="https://gist.github.com/PrivateRookie/3cc2330f9bbeb1115efb4a49f0627298" rel="noopener noreferrer">gits: tsv 解析</a> 获取完整代码.</p>
<p>可惜这次改动带来的优化非常小, 在我的电脑上反复测量, 这个版本耗时在 440 µs 左右.</p>
<h2>使用 ascii 正则</h2>
<p>rust 的 regex 正则默认使用 unicode, 相比于 ascii 编码, unicode 更复杂, 因此性能也相对较低, 刚好要解析的内容都是ascii字符, 使用 ascii 正则是否能提升解析速度呢? regex 有 <code>regex::bytes</code> 模块用于 ascii 解析, 但为了适配字段, 这里不得不使用 <code>transmute</code> 将 <code>&amp;[u8]</code> 强制转换成 <code>&amp;str</code></p>
<pre><code>fn cast(data: &amp;[u8]) -&gt; &amp;str {
    unsafe { std::mem::transmute(data) }
}
fn regex_ascii&lt;'a&gt;(input: &amp;'a str, re: &amp;regex::bytes::Regex, result: &amp;mut Vec&lt;Record&lt;'a&gt;&gt;) {
    input.lines().for_each(|line| {
        if let Some(item) = re.captures(line.as_bytes()).and_then(|captures| {
            let (_, [local_addr, local_port, remote_addr, remote_port, state, pid]) =
                captures.extract();
            let ret = Record {
                local_addr: cast(local_addr),
                local_port: cast(local_port).parse().ok()?,
                remote_addr: cast(remote_addr),
                remote_port: cast(remote_port).parse().ok()?,
                state: cast(state),
                pid: cast(pid).parse().ok()?,
            };
            Some(ret)
        }) {
            result.push(item);
        }
    });
    assert_eq!(result.len(), 377);
}
</code></pre>
<p>添加到 bench 后性能大概多少呢?, 很遗憾, 性能与 regex_borrow 差不多, 在 430 µs 左右.</p>
<h2>抛弃 regex</h2>
<p>鉴于内容格式比较简单, 如果只使用 rust 内置的 split 等方法解析性能会不会更好呢?
解析思路很简单, 使用 <code>lines</code> 得到一个逐行迭代器, 然后对每行使用 split 切分空格再逐个解析即可</p>
<pre><code>fn split&lt;'a&gt;(input: &amp;'a str, result: &amp;mut Vec&lt;Record&lt;'a&gt;&gt;) {
    input
        .lines()
        .filter_map(|line| {
            let mut iter = line.split([' ', '\t', '\r']).filter(|c| !c.is_empty());
            let local_addr = iter.next()?;
            let local_port: u16 = iter.next()?.parse().ok()?;
            let remote_addr = iter.next()?;
            let remote_port: u16 = iter.next()?.parse().ok()?;
            let state = iter.next()?;
            let pid: u64 = iter.next()?.parse().ok()?;
            Some(Record {
                local_addr,
                local_port,
                remote_addr,
                remote_port,
                state,
                pid,
            })
        })
        .for_each(|item| result.push(item));
    assert_eq!(result.len(), 377);
}
</code></pre>
<p>注意 <code>line.split</code> 只后还需要过滤不是空白的字符串, 这是因为字符串 <code>"a   b"</code> split 之后得到 <code>["a", "", "b"]</code>.</p>
<p>经测试, 这个版本测试耗时大概为 53 µs, 这真是一个<strong>巨大提升</strong>, rust 的 regex 性能确实有些问题.</p>
<p>每次 split 之后还需要 filter 感觉有些拖沓, 刚好有个<a href="https://doc.rust-lang.org/std/primitive.str.html#method.split_whitespace" rel="noopener noreferrer">split_whitespace</a>, 换用这个方法, 将新的解析方法命名为<code>split_whitespace</code>后再测试下性能</p>
<pre><code>let mut iter = line.split_whitespace();
</code></pre>
<p>令人意想不到的是性能居然倒退了, 这次耗时大概 60 µs, 仔细研究下来还是 unicode 的问题, 改用 ascii 版本的 <code>split_ascii_whitespace</code> 之后性能提升到 45 µs.</p>
<h2>手写解析状态机</h2>
<p>除了上述的方法, 我还尝试将 Record 的 local_addr 和 remote_addr 改成 <code>std::net::IpAddr</code>, 消除 <code>next()?.parse().ok()?</code> 等其他方法, 但收益几乎没有, 唯一有作用的办法是手写解析状态机.</p>
<p>大致思路是, 对于输出来说, 我们只关系它是以下三种情况</p>
<ol>
<li>换行符 NL</li>
<li>除了换行符的空白符 WS</li>
<li>非空白字符 CH</li>
</ol>
<p>只解析 LocalAddr 和 LocalPort 解析状态机如下, 如果要解析更多字段, 按顺序添加即可.</p>
<pre><code>stateDiagram-v2
    [*] --&gt; LineStart
    LineStart --&gt; LineStart:WS
    LineStart --&gt; ConsumeLocalAddr:Ch
    ConsumeLocalAddr --&gt; LineStart:NL
    ConsumeLocalAddr --&gt; LocalAddr:WS
    ConsumeLocalAddr --&gt; ConsumeLocalAddr:CH
    LocalAddr --&gt; LineStart:NL
    LocalAddr --&gt; LocalAddr:WS
    LocalAddr --&gt; ConsumeLocalPort:CH
    ConsumeLocalPort --&gt; ParsePort:NL
    ConsumeLocalPort --&gt; ParsePort:WS
    ConsumeLocalPort --&gt; ConsumeLocalPort:CH
    ParsePort --&gt; LineDone:parse ok
    ParsePort --&gt; Abort:parse error
    LineDone --&gt; LineStart:NL
    Abort --&gt; LineStart:NL
    LineDone --&gt; [*]:EOF
    Abort --&gt; [*]:EOF
</code></pre>
<p>因为代码有些复杂, 所以这里不再贴出来, 完整代码在 gits 上. 手写状态机的版本耗时大概在 32 µs 左右. 这版本主要性能提升来自手写状态机减少了循环内的分支判断.</p>
<h2>SIMD 加速?</h2>
<p>在上面手写解析的例子里, 处理过程类似与将输出作为一个 vec, 状态机作为另一个 vec, 将两个 vec 进行某种运算后输出结果, 应该能使用 simd 进行加速, 但我还没想出高效实现. 所以这里只给出可能的参考资料</p>
<ol>
<li><a href="https://github.com/liquidaty/zsv" rel="noopener noreferrer">zsv</a> 使用 simd 加速的 csv 解析库</li>
<li><a href="https://mcyoung.xyz/2023/11/27/simd-base64/" rel="noopener noreferrer">simd base64</a> 一篇介绍使用 simd 加速 base64 解析的博客, 非常推荐</li>
</ol>
<h2>总结</h2>
<p>rust regex 在某时候确实存在性能问题, 有时候使用简单的 split 的方法手动解析反而更简单性能也更高, 如果情况允许, 使用 ascii 版本能进一步提升性能, 如果你追求更好的性能, 手写一个状态不失为一种选择, 当然我不建议在生产上这么做. 同时我也期待有 simd 加速的例子.</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzUxMDg5MzUwMA==&amp;mid=2247483749&amp;idx=1&amp;sn=6b1fbad044b2ddef1c8aa360ef81e1c1&amp;chksm=f97d4db6ce0ac4a0fe8a8a5d3062cd99f8bf4f0c2ccc30d41e673df1a5d661aab32c269b1dda#rd" rel="noopener noreferrer">公众号原文</a></p>
2024-02-22T18:27:43.621720389+08:00 - 文章标题：Rust与面向对象（四）
2024-02-22T18:27:43.621843676+08:00 - 文章内容：<h2>原型法</h2>
<p>此原型法非原型模式，而是类似JavaScript中的原型扩展，在JS中，能够很轻松地为String类型“原地”扩展方法，如：</p>
<pre><code>String.prototype.isDigit = function() {
  return this.length &amp;&amp; !(/\D/.test(this));
};
</code></pre>
<p>这个能力其实很好用，但是C++无法这样，一直觉得<code>std::string</code>的功能不足，想为其添加更丰富的如<code>trim</code>/<code>split</code>之类的语义，只能采用继承或者组合代理方式：</p>
<ul>
<li>继承：用一个新类继承<code>std::string</code>，并为新类实现<code>trim</code>/<code>split</code></li>
<li>组合代理：用一个新类组合<code>std::string</code>，并为新类代理所有<code>std::string</code>的方法，包括各类构造方法和析构方法，再为新类实现<code>trim</code>/<code>split</code></li>
</ul>
<p>然后，使用<code>std::string</code>的地方替换成新类。这时候那种都比较复杂，组合的方式更复杂一些，所以也别无脑相信面向对象里“组合一定优于继承”。幸运的是，Rust能轻易完成原型法，比如有个<code>bytes</code>库提供了可廉价共享的内存缓冲区，避免不必要的内存搬运拷贝，<a href="https://docs.rust-embedded.org/rust-sysfs-gpio/bytes/struct.BytesMut.html" title="BytesMut" rel="noopener noreferrer"><code>bytes::BytesMut</code></a>实现了可变缓冲区<a href="https://docs.rust-embedded.org/rust-sysfs-gpio/bytes/struct.BytesMut.html#impl-BufMut" title="BufMut" rel="noopener noreferrer"><code>bytes::BufMut</code></a>，有一系列为其写入u8、i8、u16、i16、slice等基础类型的接口，对于基础的通用的在bytes库中已经足够了，现在有个网络模块，想往<code>bytes::BytesMut</code>中写入<code>std::net::SocketAddr</code>结构，Rust可轻易为<a href="https://docs.rust-embedded.org/rust-sysfs-gpio/bytes/struct.BytesMut.html" title="BytesMut" rel="noopener noreferrer"><code>BytesMut</code></a>扩展实现<code>put_socket_addr</code>：</p>
<pre><code>pub trait WriteSocketAddr {
    fn put_socket_addr(&amp;mut self, sock_addr: &amp;std::net::SocketAddr);
}

impl WriteSocketAddr for bytes::BytesMut {
    fn put_socket_addr(&amp;mut self, sock_addr: &amp;std::net::SocketAddr) {
        match sock_addr {
            SocketAddr::V4(v4) =&gt; {
                self.put_u8(4);        // 代表v4地址族
                self.put_slice(v4.ip().octets().as_ref());
                self.put_u16(v4.port()); 
            }
            SocketAddr::V6(v6) =&gt; {
                self.put_u8(6);        // 代表v6地址族
                self.put_slice(v6.ip().octets().as_ref());
                self.put_u16(v6.port()); 
            }
        }
    }
}
</code></pre>
<p>然后就可以使用<code>BytesMut::put_socket_addr</code>了，只需<code>use WriteSocketAddr</code>引入这个trait就可以，是不是很轻松！为何会这么容易？先看JS的原型法，其背后是原型链在支撑，调用String的方法，不仅在String对象里面查找，还会层层向String的父级、祖父级prototype查找，一旦找到就可以调用，而每个prototype本质上都是个Object，可以获取并编辑它们，ES6的继承本质上也是原型链。所以可以拿到String类的prototype，在它上面为其增加isDigit，就能让所有的String对象都能享受isDigit函数的便利，可谓十分方便。但是C++就不行了，也想拿到<code>std::string</code>的函数表，然后一通编辑为其添加<code>trim</code>/<code>split</code>行为，奈何C++不允许这危险的操作啊，只能派生子类，即便子类仅仅只包含一个<code>std::string</code>。那Rust为何可以，关键就是trait函数表与传统面向对象的虚函数表解藕了，后果就是，类型没有绑死函数表，可以为类型增加新trait函数表，然后就有了上面的Rusty原型法。类似的还可以为Rust的<code>String</code>扩展<code>is_digit</code>/<code>is_email</code>/<code>is_mobile</code>，一样地简单。一般有<code>ext</code>模块，就很可能发现原型法的身影，比如<code>tokio::io::AsyncReadExt</code>。</p>
<p>原型法是最能体现trait函数表与传统面向对象虚函数表分离优势的设计模式！注意，Rust的原型法并没有产生任何新类型，只是增加了一个新的trait函数表，所以一开始称之为“原地”扩展，是比JS更干净的原型法，个人非常喜欢用这个模式，能用就用！更进阶的，Rust还能为所有实现了<a href="https://docs.rust-embedded.org/rust-sysfs-gpio/bytes/struct.BytesMut.html#impl-BufMut" title="BufMut" rel="noopener noreferrer"><code>bytes::BufMut</code></a>的类型扩展实现<code>WriteSocketAddr</code>特型，而不仅仅只为<a href="https://docs.rust-embedded.org/rust-sysfs-gpio/bytes/struct.BytesMut.html" title="BytesMut" rel="noopener noreferrer"><code>bytes::BytesMut</code></a>实现：</p>
<pre><code>/// 可以这样读：为所有实现了ButMut特型的类型实现WriteSocketAddr
/// bytes::BytesMut也不过是T的一种，代码复用性更佳
impl&lt;T: bytes::ButMut&gt; WriteSocketAddr for T {
    fn put_socket_addr(&amp;mut self, sock_addr: &amp;std::net::SocketAddr) {
        // 同样的代码
    }
}
</code></pre>
<p>原型法跟模板方法还有些联系，也算模板方法衍生出来的设计模式，因为子类如果不依赖父类，并且子类还不需要有任何字段，不需要有自己独特的结构就能实现算法策略时，那子类也不用依赖注入到父类了，直接在父类的基础上“原地“扩展，更加轻量。总结一下模板方法的衍生变化：</p>
<p>模板方法：</p>
<ul>
<li>子类拥有自己的结构，并依赖父类的结构和行为才能完成，是模板方法</li>
<li>子类拥有自己的结构，但不依赖父类结构和行为也能完成，可不用继承转而采用组合依赖注入，最好多达2个以上组合，达成策略组合模式</li>
<li>子类不需有自己的结构（或者一个空结构），依赖父类的结构和行为就能完成，只是算法在父类模块中不通用而没实现，可不用继承也不用组合，“原地”扩展，原型法即可</li>
<li>子类不需有自己的结构，也不依赖父类，那这么独立也跟父类没任何关系了，理应属于其它模块</li>
</ul>
<p>回到面向对象，凡是Rust能轻松做到的，面向对象却无法轻松做到的，就是面向对象该被批评的点。。面向对象说我服，早知道也不把虚函数表与对象内存结构绑死了。所谓长江后浪推前浪，新语言把老语言拍死在沙滩上，即便C++20如此强大，不改变虚函数表的基础设计，在原型法上也永远追赶不上Rust语言的简洁。</p>
<h2>装饰器模式</h2>
<p>上节说到，策略模式，要是为复合类型也实现trait，就类似装饰器模式，因为装饰器无论是内部委托成员，还是外部装饰器自己，都得实现同一个名为Decorate的trait，就是为了让它们可以相互嵌套组合：</p>
<pre><code>trait Decorate {
    fn decorate(&amp;mut self, params...);
}

/// 一个静多态的装饰器
struct SomeDecorator&lt;D: Decorate&gt; {
    delegate: D,    // 必要的委托
    ...
}

/// 还得为Decorator自己实现Decorate特型
impl&lt;D: Decorate&gt; Decorate for SomeDecorator&lt;D&gt; {
    fn decorate(&amp;mut self, params...) {
        // 1. SomeDecorator itself do sth about params 
        self.do_sth_about_params(params...); // 这是真正要装饰的实现
        // 2. then turn self.delegate
        self.delegate.decorate(params...);    // 这一句都相同，1、2步的顺序可互换
    }
}

/// 另一个装饰器
struct AnotherDecorator&lt;T: Decorate&gt; {
    delegate: T,
    ...
}

impl&lt;D: Decorate&gt; Decorate for AnotherDecorator&lt;D&gt; {
    fn decorate(&amp;mut self, params...) {
        // 1. AnotherDecorator itself do sth about params 
        self.do_sth_about_params(params...);
        // 2. then turn self.delegate
        self.delegate.decorate(params...);    // 这一句都相同
    }
}

/// 必要的终结型空装饰器
struct NullDecorator;

impl Decorator for NullDecorator { /*do nothing*/ }

/// 使用上
let d = SomeDecorator::new(AnotherDecorator::new(NullDecorator));
d.decorate();
</code></pre>
<p>SomeDecorator/AnoterDecorator是真正的装饰器，会有很多个，功能各异，每个Decorator所包含的相应的结构可能也不同。装饰器在使用上，就像链表一样，一个处理完之后，紧接着下一个节点再处理，它把链表结构包含进了装饰器的结构里面，并用接口/trait来统一类型。上述实现有重复代码，就是调用委托的装饰方法，还能继续改进：</p>
<pre><code>/// 装饰的其实是一个处理过程
trait Handle {
    fn handle(&amp;mut self, params...);
}

trait Decorate {
    fn decorate(&amp;mut self, params...);
}

/// 装饰器的终结
struct NullDecorator;

impl Decorate for NullDecorator {
    fn decorate(&amp;mut self, params...) {
        // do nothing
    }
}

/// 通用型装饰器，像是链表节点串联前后2个处理器节点
struct Decorator&lt;D: Decorate, H: Handler&gt; {
    delegate: D,
    handler: H,   // 这又是个干净的模板方法，将变化交给子类
}

/// 通用装饰器本身也得实现Decorate特质，可以作为另一个装饰器的D
impl&lt;D: Decorate, H: Handler&gt; Decorate for Decorator&lt;D, H&gt; {
    fn decorate(&amp;mut self, params...) {
        // 这两步可互换
        self.handler.handle(params);
        self.delegate.decorate(params);
    }
}

/// 下面的处理器只关注处理器自己的实现就好了
struct SomeHandler { ... };

impl Handler for SomeHandler { ... }

struct AnotherHandler { ... };

impl Handler for AnotherHandler { ... }

/// 使用上
let d = Decorator {
    delegate: Decorator {
        delegate: NullDecorator,
        handler: AnotherHandler,
    },
    handler: SomeHandler,
};
d.decorate(params...);
</code></pre>
<p>可以看出，装饰器很像链表，emm...大家都知道链表在Rust中较复杂，那链表有多复杂，装饰器就有多复杂。上面的静多态实现也是不行的，不同的装饰器组合，就会产生不同的类型，类型可能随着Handler类型数目增加呈其全排列阶乘级类型爆炸，忍不了，必须得换用指针。装饰器模式，Rust实现起来不如传统面向对象，面向对象天然动多态，且Decorator继承可以让D、H两部分合为一体，让H也成装饰类的一个虚函数，都在this指针访问范围内，简单一些。而Rust将装饰器拆解成了链表型，将装饰器的底层结构还原了出来，确实装饰器可以用链表串联起各个处理器一个接一个地调用，效果一样的。只是面向对象技巧隐藏了链表的细节。</p>
<p>不过Rust有个很牛逼的装饰器，就是迭代器的map、step_by、zip、take、skip这些函子，它们可以随意串联组合调用，本质就是装饰器，只不过仅限于用在迭代器场景。如果装饰器能这样实现，能惰性求值，也能够编译器內联优化，就太强了。不过，各个装饰器功能不同，恐怕不能像迭代器函子那样都有清晰的语义，因此没有统一的装饰器库。不过装饰器实现时，肯定可以借鉴迭代器的函子思路。这样一来的话，Rust的装饰器又丝毫不弱于传统面向对象的了。而且，高，实在是高，妙，实在是妙！</p>
<pre><code>/// 以下仅作摘选，让大家一窥迭代器函子的装饰器怎么玩的
pub trait Iterator {
    type Item;

    // Required method
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // Provided methods
    // 像下面这样的函数还有76个，每个函数都映射到一个具体的装饰器，它们都返回一个装饰函子impl Iterator&lt;Item = Self::Item&gt;
    // 装饰器函数基本都定义完了，未来无法扩展？还记得原型法吗，为所有实现了Iterator的类型实现IteratorExt
    // 仅挑选一个step_by作为案例
    #[inline]
    #[stable(feature = "iterator_step_by", since = "1.28.0")]
    #[rustc_do_not_const_check]
    fn step_by(self, step: usize) -&gt; StepBy&lt;Self&gt;
    where
        Self: Sized,
    {
        StepBy::new(self, step)
    }
}

/// StepBy装饰器，如第一种实现那样的写法
pub struct StepBy&lt;I&gt; {
    iter: I,    // 装饰器的delegate
    step: usize,
    first_take: bool,
}

/// 再为StepBy&lt;I&gt;实现Iterator
impl&lt;I&gt; Iterator for StepBy&lt;I&gt;
where
    I: Iterator,
{
    type Item = I::Item;

    #[inline]
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.spec_next()
    }
}

// 使用上，有别于传统装饰器模式从构建上去串联，这是利用返回值链式串联，顿时清晰不少
vec![1, 2, 3].iter().skip(1).map(|v| v * 2);
</code></pre>
<h2>小结</h2>
<p>至此，模板方法的变化告一断落。之前，有人说Rust不支持面向对象，导致Rust不好推广，实际上并不是，哪个OO设计模式Rust实现不了，还更胜一筹。因此，并非Rust不支持面向对象！有些设计模式，Rust天生也有，如：</p>
<ul>
<li>单例模式：其实单例模式如果不是为了懒加载，跟使用全局变量没啥差别；如果为了懒加载，那<code>lazy_static</code>或者<code>once_cell</code>就够用。（补充：标准库已经标准化成<code>OnceLock</code>了）</li>
<li>代理模式：NewType模式作代理挺好；或者原型法“原地”扩展代理行为</li>
<li>迭代器模式：Rust的迭代器是我见过最NB的迭代器实现了</li>
<li>状态机模式：<a href="https://doc.rust-lang.org/stable/book/ch17-03-oo-design-patterns.html" rel="noopener noreferrer">Rust语言官方文档中的NewType+enum状态机模式</a>，这种静多态的状态机非常严格，使用上都不会出错，所有状态组合还可以用enum统一起来，比面向对象的状态机模式要好</li>
</ul>
<p>还有一些设计模式，跟其它模式很像，稍加变化：</p>
<ul>
<li>适配器模式：同代理模式差别不大，很可能得有自己的扩展结构，然后得有额外“兼容处理”逻辑来体现“适配”</li>
<li>桥接模式：就是在应用策略模式</li>
<li>过滤器模式：就是在应用装饰器模式</li>
</ul>
<p>还有一些设计模式，读者可自行用Rust轻松实现，如观察者模式之流。后续不会为这些设计模式单独成文了，除非它有点意思，访问者模式就还可以，只不过实际应用不咋多。有想用Rust实现哪个设计模式有疑问的，可留言交流。</p>
<p>罗列所有设计模式没啥意思，我也无力吐槽这么多设计模式，至今很多人仍区分不清某些设计模式的区别，因为设计模式在描述它们的时候，云里雾里的需求描述，关注点、应用场景不一样云云，什么模式都得来一句让“抽象部分”与“实现部分”分离，跟都整过容一样相似的描述，让人傻傻分不清。至今我再看各种设计模式，想去了解其间区别，都觉得无聊了，浪费时间！被大众广泛记住的设计模式就那么几个，因为基础的设计就那么几个，当你在使用接口、指针/引用、组合的时候，其实就在不知不觉中使用设计模式了。</p>
<p>上段是在批评设计模式没错，并不是说设计模式一无是处，能总结出模式作为编程界通用设计语言意义非凡。懂它肯定比不懂的强，要是都能区分清各类设计模式了，肯定是高手中的高手了，看懂这一系列文章不难。设计模式的套用，归根结底是为了代码复用，良好的可读性。大家看到相似模式的代码，一提那种设计模式就能明白。遗憾的是，即便是同一个设计模式，因为乱七八糟的类型、胡乱命名、粗糙的掺杂不少杂质的实现，为不停变化的需求弄的面目全非者，让人读起来，实在很难对的上有某种设计，这并非设计模式的锅，而是编程素质不专业、太自由发挥、总见多识少地自创概念/二流招式的毛病招致的。</p>
<p>在这方面，Rust的解决方案 <strong>极具</strong> 吸引力。后续对比着面向对象，讲讲Rusty那味，味道不错但更难掌握，属于基础易懂，逻辑一多就复杂(废话)！</p>
2024-02-22T18:27:43.621894625+08:00 - 文章标题：N-API的JS堆对象生命周期管理
2024-02-22T18:27:43.622015316+08:00 - 文章内容：<h1><code>N-API</code>的<code>JS</code>堆对象生命周期管理</h1>
<p><code>N-API</code>是<code>Node API</code>的简写，同时也是<code>nodejs</code>的<code>JS VM</code>（链）接入原生模块<code>.node</code>文件的<strong>应用程序二进制接口</strong><code>(i.e. ABI)</code>。借助<code>N-API</code>引入的抽象隔离，升级<code>nodejs</code>运行时（虚拟机）</p>
<ul>
<li>【编译】不要求对原生扩展模块<strong>重新编译</strong> — 为<code>nodejs</code>的不同版本分别准备不同的原生模块<code>build</code>真的好麻烦。</li>
<li>【运行】不导致原生模块<strong>程序崩溃</strong> — 精读每一版<code>changelogs</code>清单和微调原生模块源码更耗时费力。</li>
</ul>
<p><code>N-API</code>开放接口在<code>nodejs 10+</code>后才逐步稳定，和成为<code>nodejs c-addon</code>的主流编程标准。</p>
<p>不久前，我有机会在工程实践中独立完成“给<code>node-webkit</code>容器编写原生扩展模块的”程序开发任务。虽然扩展模块自身的业务处理逻辑很简单 — 馁馁的“胶水”代码，但其涉及到了跨越多个<code>FFI</code>接口调用的<code>JS</code>对象<strong>缓存</strong>处理。初版程序<strong>缓存不住</strong><code>JS</code>堆内存中的变量值，因为<code>JS VM</code>的<code>GC</code>总是在<code>FFI</code>接口调用的<strong>间隙</strong>回收由原生模块缓存的<code>JS</code>对象和导致程序崩溃。由此，我特意“死磕”<a href="https://nodejs.org/api/n-api.html" rel="noopener noreferrer">C/C++ addons with Node-API</a>厂方文档，在解决工程难题的同时汇总实践收获写下此文。</p>
<p>文章以名词解释统一术语理解开篇，以对比不同版本<code>ABI</code>标准引题，以技术细节展开讨论为依据，最后向读者图文并茂地描述我个人创新的实践方案。</p>
<h2>名词解释</h2>
<h3><code>nodejs c-addon</code></h3>
<p><code>nodejs</code><strong>原生</strong>扩展模块。所谓“原生”是相对<code>JS</code>模块而言的。它必须由【系统编程语言<code>C / Cpp / Rust</code>】编写，并经由<code>nodejs</code>开放接口<code>N-API</code>，</p>
<ol>
<li>接入<code>nodejs</code>的<code>JS VM</code>，并</li>
<li>与<code>nodejs</code>交换数据·互操作。</li>
</ol>
<p>为了文字简练，下文也将其记作为<code>addon</code>。</p>
<p><code>nodejs c-addon</code>与<code>Commonjs Module</code>在科技树上处于相同的生态位，和对“上游”调用端的<code>JS</code>业务代码呈现一致的调用方式。</p>
<h3><code>JS</code>堆对象</h3>
<p>它既包括由<code>JS</code>程序自身构造的对象实例，也包含由系统程序从<code>addon</code>内调用<code>N-API</code>接口（比如，<a href="https://nodejs.org/api/n-api.html#napi_create_object" rel="noopener noreferrer">napi_create_object()</a>）实例化的<code>JS</code>对象。它们都</p>
<ol>
<li>被保存在<code>JS VM</code>的<strong>堆</strong>内存中，和</li>
<li>被<code>Rust</code><strong>栈</strong>内存中的<a href="https://nodejs.org/api/n-api.html#napi_value" rel="noopener noreferrer">napi_value</a>可修改<strong>原始指针</strong>引用。</li>
</ol>
<h3><code>N-API</code>引用计数</h3>
<p>它是指向<code>JS</code>堆对象的“<code>FFI</code>引用计数”智能指针（后文有图，应该会更直观些）。其</p>
<ol>
<li>被保存于<code>JS VM</code>的<strong>堆</strong>内存中，和</li>
<li>被<code>Rust</code><strong>栈</strong>内存中的<a href="https://nodejs.org/api/n-api.html#napi_ref" rel="noopener noreferrer">napi_ref</a>可修改<strong>原始指针</strong>引用。即，<code>addon</code>端<code>Rust</code>程序拿到的是指向了“智能指针”的“指针”。</li>
<li>被用于<strong>阻止</strong><code>JS VM</code>的<code>GC</code><strong>回收</strong>正活跃于<code>addon</code>端的<code>JS</code>堆对象。这就赋予了 @Rustacean 从<code>JS VM</code>外部干预<code>JS</code>对象生命周期的能力。<code>React Native</code>可都做不到这一点。</li>
</ol>
<h3><code>WASM</code>垫片程序</h3>
<p>它既包括由<code>wasm-bindgen-cli</code>生成的<code>JS</code>垫片程序文件，也包含由<code>wasm-bindgen crate</code>导出的<code>Rust</code>开发框架。正是<code>js &lt;-&gt; Rust</code>两端垫片程序的协同配合，<code>JS</code>堆对象才几乎被“投影为”<code>Rust</code>所有权（栈）变量。比如，<code>JS</code>堆对象的<a href="https://docs.rs/wasm-bindgen/latest/wasm_bindgen/struct.JsValue.html" rel="noopener noreferrer">wasm_bindgen::JsValue</a>（<strong>似</strong>智能指针）<strong>结构体</strong>就比<a href="https://docs.rs/nj-sys/latest/nj_sys/type.napi_value.html" rel="noopener noreferrer">nj_sys::napi_value</a>可修改<strong>原始指针</strong>更能发挥<code>Rust</code>类型系统与<code>Borrow / Drop Checker</code>对程序正确性的保障力。没有“黑魔法”，满眼都是对垫片程序开发迭代的<strong>工作量</strong>。</p>
<h2><code>WASM vs. N-API</code>堆对象生命周期管理策略</h2>
<p>简单地讲，生命周期策略的差异取决于【垫片程序】的“薄/厚”。因为<code>WASM</code>应用场景多（包括但不限于：网页、<code>nodejs</code>，<code>wasm-runtime</code>独立虚拟机），社区关注度高，<code>wasm-bindgen</code>工具链迭代速度快，所以，<code>wasm &lt;-&gt; js</code>垫片程序就“厚”。<code>JS</code>堆对象向<code>Rust</code>的“投影”就更像【智能指针】，而不是“裸奔的”原始指针。<code>WebAssembly</code>工作组甚至规划将垫片程序逐步“固化”至<code>wasm-runtime</code>内（比如，<a href="https://github.com/tc39/proposal-weakrefs" rel="noopener noreferrer">TC39弱引用提案</a>与<a href="https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md" rel="noopener noreferrer">引用类型提案</a>等）以完备核心功能。工作量到位自然对接平滑！这不是黑魔法，而是真金白银的血汗努力。</p>
<p>相反，<code>nodejs c-addon</code>的应用场景就要少得多了。所以，技术社区鲜有热情面向<code>N-API</code>开放接口编写功能丰富的<code>addon &lt;-&gt; js</code>垫片程序。于是，@Rustacean 不得不直面</p>
<ol>
<li>“裸奔的”原始指针</li>
<li>简陋的<a href="https://docs.rs/nj-sys/4.0.0/nj_sys/" rel="noopener noreferrer">Rust Bindings</a> —  与<code>C</code>头文件概念对等的<code>Rust</code>语言项</li>
<li>“安慰剂”式的<strong>宏</strong>编程工具。因为缺乏了<code>js</code>垫片程序的协同呼应，几个<code>Rust</code>宏也只是杯水车薪，能“糖”的内容很少。</li>
<li>转移更多精力从【业务逻辑实现】至【<code>FFI</code>编程】，并与各种<code>FFI</code>技术细节做“斗争”。赶快补课<a href="https://rustcc.cn/article?id=98adb067-30c8-4ce9-a4df-bfa5b6122c2e" rel="noopener noreferrer">内存布局理论知识</a>去吧！</li>
</ol>
<p>具体地讲，在<code>Rust - WASM</code>程序上下文中，披上了“智能指针”马甲的<code>JS</code>堆对象几乎完全“锈化”了。@Rustacean 可忽视<code>JS VM</code>垃圾收集器的干扰和：</p>
<ol>
<li><code>static</code>全局缓存<code>JS</code>堆对象。而不必担心<strong>仅</strong>活跃于<code>addon</code>的<code>JS</code>堆对象会被<code>JS VM</code>的<code>GC</code>回收。
<ul>
<li>相对<code>FFI</code>函数的<strong>单次</strong>调用执行周期，<strong>延长</strong><code>JS</code>堆对象的生命周期。</li>
</ul>
</li>
<li><code>{ .. }</code>块作用域限定<code>JS</code>堆对象，<strong>按需</strong>释放不再访问的变量值，提高内存利用效率。就有<strong>多</strong>局部变量的<strong>大</strong>函数而言，这可明显地降低<code>JS</code>堆内存占用的瞬时峰值。
<ul>
<li>相对<code>FFI</code>函数的<strong>单次</strong>调用执行周期，<strong>缩短</strong><code>JS</code>堆对象的生命周期</li>
</ul>
</li>
</ol>
<p>另一方面，<code>N-API</code>没有功能面面俱到的垫片程序。所以，@Rustacean 做不到仅凭<code>Rust</code>基本语法项就对<code>FFI</code>另一端的<code>JS</code>堆对象执行【全局缓存】或【块作用域】按需回收的程序处理。甚至（重点来了），即便<code>JS</code>端代码<strong>刻意</strong>保留了已<code>FFI</code>导出堆对象的引用，<code>addon</code>端（栈内存）所持有的原始指针依旧会，在<code>FFI</code>函数执行之后，丢失其原本指向的值和成为“野”指针。我怀疑<code>JS VM</code>就算没有回收也至少挪动了被导出<code>JS</code>堆对象的内存位置。由此，@Rustacean 需要在<code>addon</code>业务代码中额外实现部分本该由垫片程序完成的“公共服务”功能，包括但不限于：</p>
<ol>
<li>徒手维护<code>N-API</code>引用计数智能指针，以“锁住”<code>JS</code>堆对象不被<code>JS VM</code>的<code>GC</code>回收 — <strong>延长</strong><code>JS</code>堆对象的生命周期。</li>
<li>调用<code>N-API</code>程序接口构造可层叠嵌套的作用域【块】 — <strong>缩短</strong><code>JS</code>堆对象的生命周期。</li>
</ol>
<p>这的确是一次接触底层“自己动手丰衣足食”的机会，但绝对不是什么令人愉快的开发体验。千言万语汇聚一张图（左侧<code>WASM</code>，右侧<code>nodejs c-addon</code>）促成读者思绪的豁然开朗：</p>
<p><img src="https://github.com/stuartZhang/my_rs_ideas_playground/assets/13935927/f18ae535-1ae4-473d-b143-9df2eb09f46c" alt="生命周期策略对比"></p>
<h2><code>N-API JS</code>堆对象生命周期管理的技术细节</h2>
<p><code>addon</code>对<code>JS</code>堆对象生命周期的管理分为如下三种情况（看图吧，一图抵千词）：</p>
<p><img src="https://github.com/stuartZhang/my_rs_ideas_playground/assets/13935927/932b381d-a653-47b0-9fec-d9bba587b606" alt="技术细节"></p>
<p>由上图可见，真实数据被保存于<code>JS</code>端（堆）内存中。<code>Rust</code>端（栈）内存仅持有随时可能失效的原始指针。所以，@Rustacean 需要调用特定的<code>N-API</code>接口，远程操控<code>JS</code>堆对象的活跃周期。但是，<code>N-API</code>接口并不易用。这表现为...</p>
<h3><code>N-API</code>引用计数智能指针不智能</h3>
<ol>
<li>
<p>没有<a href="https://rust-unofficial.github.io/patterns/patterns/behavioural/RAII.html" rel="noopener noreferrer">RAII Guard</a>对活跃引用数量的<strong>自动</strong>跟踪。@Rustacean 还需书面编写<code>N-API</code>接口调用和<strong>人工</strong>增减引用个数跟踪引用复本数量 — 这是传统的缺陷产出“大户”。</p>
</li>
<li>
<p><strong>零</strong>引用数量<strong>不</strong>意味着<code>GC</code>回收。@Rustacean 还需显式地析构掉<code>N-API</code>【引用计数】智能指针实例，才能促使被“持久化于内存”的<code>JS</code>堆对象接受<code>GC</code>回收。否则，内存泄漏！具体作法请参见如下伪码</p>
<pre><code>use ::nj_sys::{napi_delete_reference, napi_reference_unref};
use ::node_bindgen::core::napi_call_result;
let result = Box::into_raw(Box::new(u32::MAX));
// 1. 将引用计数值减一
napi_call_result!(napi_reference_unref(
    &lt;N-API 调用上下文&gt;,
    &lt;N-API 引用计数·智能指针&gt;,
    result // 引用计数减一之后的结果数值
)).unwrap();
let result = unsafe { Box::from_raw(result) };
// 2. 判断减一后的最新引用计数值是否已经归零。
if *result == 0 { // 当且仅当不再有任何 N-API 引用复本还指向该 JS 堆对象时，
    // 3. 显式地释放引用计数智能指针实例。
    napi_call_result!(napi_delete_reference( // 这一步是必须的。要不然，内存就漏了！
        &lt;N-API 调用上下文&gt;,
        &lt;N-API 引用计数·智能指针&gt;
    )).unwrap();
}
</code></pre>
</li>
<li>
<p>只有四类<code>JS</code>堆对象支持<code>N-API</code>引用计数。它们分别是</p>
<ul>
<li><code>napi_object</code> — <code>ECMAScript</code>规范中的<code>Object</code></li>
<li><code>napi_function</code> — <code>ECMAScript</code>规范中的<code>Function</code></li>
<li><code>napi_symbol</code> — <code>ECMAScript</code>规范中的<code>Symbol</code></li>
<li><code>napi_external</code> — 类似于<code>ECMAScript</code>中的<code>Blob</code>，专门引用<strong>进程外</strong>的某种“黑盒<code>opaque</code>”资源。</li>
</ul>
</li>
<li>
<p>若多个<code>N-API</code>引用计数指针实例（注：不是引用复本）都指向同一个<code>JS</code>堆对象，那么只有当全部<code>N-API</code>引用计数指针实例都被<code>napi_delete_reference()</code>处理后，“持久化于内存”的<code>JS</code>堆对象才被允许<code>GC</code>回收。</p>
</li>
</ol>
<h3>可逃逸作用域与作用域提升不实用</h3>
<p>在上图中的（普通）作用域<code>napi_handle_scope</code>禁止其内部的<code>JS</code>堆对象溢出作用域，和向外传值。即，普通作用域是“多入无出”的。</p>
<p>【可<strong>逃逸</strong>作用域<code>napi_escapable_handle_scope</code>】有限松绑了这条限制。它允许作用域像<strong>函数</strong>一样向外输出一个且仅一个值，而输出形式不是<code>Rust</code>块表达式【返回值】，而是<code>JS</code>堆对象【作用域·提升<code>handle promoting</code>】。类比<code>JS</code>动态语言的【变量提升<code>variable hoisting</code>】,</p>
<ul>
<li>相同点：块内声明的变量可从块外引用和访问</li>
<li>不同点：【可逃逸作用域】有且只有一个块内声明的变量可从块外被访问。否则，程序崩溃。</li>
</ul>
<p>所以，可逃逸作用域是“多入单出”的面向实用有限放开。再看图吧，一图抵千词！</p>
<p><img src="https://github.com/stuartZhang/my_rs_ideas_playground/assets/13935927/449a1c82-b037-4370-8d13-dbc7fd773305" alt="可逃逸作用域"></p>
<p>在作用域层叠嵌套的场景下，这绝对是“盛产”缺陷的泥沼。@Rustacean 需要从程序设计之初就努力避免从<code>Rust</code>端远程管理<code>JS</code>变量的作用域。最好从产品架构上，<strong>多用<code>addon</code>构建【业务组件】，少封装【功能模块】，从根本上规避<code>Rust &lt;-&gt; JS</code>复杂互操作出现</strong>。</p>
<h2>智能化<code>N-API</code>引用计数 — “二段式”引用计数优化法</h2>
<p>相比于最低也需要【过程宏】作为抽象工具才能描述清楚的<code>JS</code>堆对象<strong>作用域</strong>，<code>N-API</code>引用计数智能化改造还是有捷径可走的。</p>
<p>简单地讲，将对引用复本数量变化的跟踪任务委托给遵循<code>RAII with Guard</code>设计模式的智能指针<code>std::rc::Rc&lt;napi_ref&gt;</code>处理。然后，<code>addon</code>业务实现代码仅需负责</p>
<ol>
<li>【始】调用<code>napi_create_reference()</code> 接口，构造一个<strong>单复本</strong>引用计数指针实例，锁住<code>JS</code>堆对象不被<code>GC</code>回收。</li>
<li>【末】调用<code>napi_reference_unref()</code>与<code>napi_delete_reference()</code>接口，清空引用复本与析构唯一的引用计数指针实例，解锁<code>GC</code>回收<code>JS</code>堆对象。</li>
</ol>
<p>接着看图，依旧一图抵千词！</p>
<p><img src="https://github.com/stuartZhang/my_rs_ideas_playground/assets/13935927/2b78ea18-225b-4d96-b97c-ba91947df619" alt="二段式引用计数优化法"></p>
<p>于是，整个设计方案的“难点”就聚焦于：</p>
<ol>
<li><strong>监听</strong>智能指针<code>std::rc::Rc&lt;napi_ref&gt;</code>的引用复本清空<strong>事件</strong>，并</li>
<li>在事件处理函数内，调用<code>napi_reference_unref()</code>与<code>napi_delete_reference()</code>接口通知<code>VM GC</code>回收<code>JS</code>堆对象。</li>
</ol>
<p>难点不难，因为<a href="https://rustcc.cn/article?id=a9198cb9-f16c-4e2b-b30e-6c63eed1cd52" rel="noopener noreferrer">Newtypes</a>设计模式允许 @Rustacean</p>
<ol>
<li>对<code>std::rc::Rc&lt;napi_ref&gt;</code>做<code>AOP</code>编程。以</li>
<li>“拦截+重写”<code>std::rc::Rc&lt;napi_ref&gt;</code>的析构函数<code>&lt;Rc as Drop&gt;::drop(&amp;mut self)</code>。于是，</li>
<li>在每个引用复本的析构处理后，都<strong>重新统计</strong>剩余引用复本的数量。最后，</li>
<li>若<strong>没有</strong>剩余引用复本了，就立即调用<code>N-API</code>接口<code>napi_reference_unref()</code>与<code>napi_delete_reference()</code>。</li>
</ol>
<p>文章写得再自恰也不如呈现一段既注释丰富又可独立运行的参考实现[<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=ae0cb8d0a99d1f729d5b9dba3458f009" rel="noopener noreferrer">例程</a>]来得清晰明白。整个例程由四个部分组成：</p>
<ol>
<li>模块<code>nj_sys</code>模拟<a href="https://crates.io/crates/nj-sys" rel="noopener noreferrer">nj_sys crate</a>的部分导出项，因为<code>nj_sys crate</code>并没有入选<code>playground.org</code>的<code>top 100</code>热门依赖包<a href="https://github.com/rust-lang/rust-playground/blob/main/compiler/base/Cargo.toml" rel="noopener noreferrer">榜单</a>。</li>
<li>模块<code>napi_rc</code>包含了对智能指针<code>std::rc::Rc&lt;napi_ref&gt;</code>的<code>AOP</code>封装。</li>
<li>函数<code>napi_export_method()</code>模仿<code>nodejs c-addon</code>的<code>FFI</code>导出函数。</li>
<li>入口函数<code>main()</code>模仿<code>JS</code>程序调用<code>Rust-FFI</code>函数<code>napi_export_method()</code>。</li>
</ol>
<h3>“二段式”引用计数优化方案的裨益</h3>
<ol>
<li>【程序性能】将<code>FFI</code>调用次数减少至一个常量<code>3</code>。</li>
<li>【代码健壮性】将引用复本的数量跟踪任务从易错的人工完成转为机器自动完成。<code>addon</code>业务代码仅需关注引用复本的<strong>个数归零</strong>事件。</li>
</ol>
<h2>结束语</h2>
<p>关于<code>nodejs c-addon</code>技术方向，我这次仅准备了上述偏【编程】内容与大家分享。其实，交叉编译与动态库链接也是一项可以聊出些许深度的话题。比如，如何做到“从一个工程，一个分支，一套<code>Rust</code>程序同时编译出三版<code>.node</code>链接库文件，以分别适用于<code>nodejs / nwjs / electron</code>三款应用程序容器”的呢？。哎！无处不是“黑科技” — 从条件编译，至编译时修改链接目标。在我输出下一篇相关主题的文章前，感兴趣的读者不防率先品鉴我的另一个<code>github</code>工程<a href="https://githubfast.com/stuartZhang/request-window-attention" rel="noopener noreferrer">request-window-attention</a>寻找答案，和给我的工程点个<code>star</code>！</p>
<p>创作不易，值得（文章）点赞，（<code>github</code>工程）点<code>star</code>，和（两者都）转发。</p>
2024-02-22T18:27:43.622068419+08:00 - 文章标题：Rust与面向对象（三）
2024-02-22T18:27:43.622137429+08:00 - 文章内容：<h2>策略模式</h2>
<p>上节说到，模板方法变化一下就能成策略模式，怎么变化的？且看策略模式典型案例：</p>
<pre><code>pub trait Fly {
    fn fly(&amp;self);
}

pub trait Quack {
    fn quack($self);
}

/// 先以静多态的方式实现
/// 似 trait Fly + Quack就是Duck，只是Fly和Quack独立地变化
struct Duck&lt;F, Q&gt; 
where
    F: Fly,
    Q: Quack,
{
    fly_behabior: F,      // 单看这个成员，与模版方法如出一辙
    quack_behavior: Q,    // 一样，将不同的算法部分交给子类去实现
}

impl&lt;F, Q&gt; Duck&lt;F, Q&gt; 
where
    F: Fly,
    Q: Quack,
{
    pub fn new(fly_behavior: F, quack_behavior: Q) {
        Self { fly_behavior, quack_behavior }
    }
}

/// 实现不同的Fly、Quack策略，参考下图，省略...
/// 下图引用自 Oreilly.Head First Design Pattern
</code></pre>
<p><img src="https://pic.imgdb.cn/item/6586c5e3c458853aef85789f.jpg" alt="Duck UML设计图"></p>
<p>以上是策略模式的简单案例，策略模式可以说是模板方法的衍生变化。还记得上一章中第一种模板方法的实现方式不，单看Fly就是模板方法：模板方法里子类完全不依赖父类，干净地完成算法策略，那子类就能够依赖注入到父类中；最好这种子类不止一个，比如不仅有Fly还有Quack，就是纯正的策略组合模式了。了解这种变化可以帮助区分二者，比那说不清道不明的优缺点、适用场景描述能让你更清晰、透彻地认识到两者的差别与联系。</p>
<p>策略模式，公认的妙。上面是静多态实现的策略模式，会遇到类型爆炸的问题，比如有2种飞行方式、3种呱呱叫方式，那总共有2*3=6种复合类型，体现了组合是类型系统中的积类型。在嵌入式上，因为内存环境限制，类型爆炸导致程序大小变大成了问题，不得不改用动多态，以减少类爆炸带来的影响。</p>
<pre><code>/// 动多态，类型统一了，类型也不会爆炸了
struct DynamicDuck {
    fly_behavior: Box&lt;dyn Fly&gt;,
    quack_behavior: Box&lt;dyn Quack&gt;,
}
</code></pre>
<p>面向对象语言，都是动多态，Java对象皆引用，当引用没地方用了就垃圾回收；C++没有指针则玩不转面向对象，只可能将子类指针赋值给父类指针来多态，无法将子类对象赋值给父类对象来多态吧！所以面向对象的策略模式是动多态，天然无类型爆炸问题。</p>
<p>那类型爆炸一定差吗，类型统一就肯定好吗？先讨论下类型爆炸合理不。自然界生物划分“界门纲目科属种”，动物界有那么多动物，比如都是猫科动物，难道老虎和狮子还不配拥有个自己的类型吗，只能共用猫类型吗？要是想为老虎这个类型单独实现点东西，但不想为狮子也实现这个东西，共用猫类型就不行了！这样看起来，接受类型爆炸挺好，类型完整，也没几个类型，程序大小允许就可以，相比于动不动就异步的task、协程，只要不是大规模类型爆炸，可以忍。而类型统一就会造成一种“类型丢失”，它的不良影响发生在后续为Duck添加其它行为时，这些行为并非所有Duck都需要的时候。比如为绿头鸭实现捕猎，为橡皮鸭实现电动，它们不再是所有鸭子都应有的行为，已有点不再适合使用新策略扩展（可不是所有扩展的行为都是鸭子通用型的Swim、Display，策略模式只拣好的说），但动多态却因“类型丢失”而不知所措，这其实是个难处理的点，本质是为了减少类型爆炸而采用动多态统一类型的牺牲。</p>
<pre><code>/// 静多态可以直接别名
type MallardDuck = Duck&lt;...&gt;;
type RubberDuck = Duck&lt;...&gt;;
type DecoyDuck = Duck&lt;...&gt;;


/// 动多态因“类型丢失”，只能使用NewType，并在NewType中约束DynamicDuck。
/// 那这样，类型还是难免爆炸了啊！
struct MallardDuck(DynamicDuck);
struct RubberDuck(DynamicDuck);
struct DecoyDuck(DynamicDuck);

/// 仅为绿头鸭MallardDuck实现捕猎
impl MallardDuck {
    fn hunt(&amp;self) {
        ...
    }
}
</code></pre>
<p>动多态策略模式再往下写很可能就开始坏味道了。为了解决这个问题，各种奇招就来了，如不管三七二十一，先把捕猎行为塞进Duck中，管其它鸭子会不会错用呢；或者，为橡皮鸭RubberDuck、木头鸭WoodDuck也实现个假的捕猎，这样“捕猎”就又符合新的策略了，又能使用策略模式了；又或者，再来次继承把绿头鸭子类化吧，然后单独给绿头鸭实现捕猎。。然而新类型MallardDuck一方面与动多态复合类型的Duck意义有冲突，不得不在文档中留下一句提醒使用者：“如果想用MallardDuck，请勿使用DynamicDuck构建，而是使用更具体的MallardDuck！”；另一方面，其它类型的Duck也需要子类化吗，若是的话岂不是又免不了类型爆炸了！策略模式这时正失去优雅的光环，它还是那个妙不可言的“策略模式”吗？</p>
<p>Rust语言，则可以静多态一路走到黑，<code>Duck&lt;F, Q&gt;</code>类型当参数时一直泛型约束使用下去。这样看起来，静多态是一种挺好的应对策略模式后续变化的解决方案。Rust还有一种方式，可以终止这种“一直”，就是将有限的静多态类型通过enum和类型统一起来，然后再使用时就不必继续用泛型了，用这个enum和类型就好了。这是个好方法，但也有个弊端，enum和类型终止了模块之外的“扩展性”！在模块之外，再也无法为模块内的enum和类型扩展其它Duck实现，而动多态和一直泛型约束的静多态，则仍不失模块外的扩展性。</p>
<p>策略模式还有个问题，值得探讨，Duck也会飞，也会呱呱叫了，那有没有必要为Duck也实现Fly、Quack特型呢？</p>
<pre><code>/// 有没有必要为Duck实现Fly/Quack trait？
impl&lt;F, Q&gt; Fly for Duck&lt;F, Q&gt; 
where
    F: Fly,
    Q: Quack,
{
    fn fly(&amp;self) {
        self.fly_behavior.fly();
    }
}

impl&lt;F, Q&gt; Quack for Duck&lt;F, Q&gt;
where
    F: Fly,
    Q: Quack,
{
    fn quack(&amp;self) {
        self.quack_behavior.quack();
    }
}
</code></pre>
<p>这是个令人迷惑的选项，个人很讨厌这种“都可以”的选项，让人迟迟下不了决策。很多人从“应该不应该”的角度出发，会得到“应该”的答案，Duck应该会飞，所以为Duck实现了Fly特型，后面就可以用Fly来特型约束了。其实，若实现了，就像是另外一个设计模式——装饰器模式了。但我不建议普通的策略模式这样实现，将Fly和Quack组合起来的Duck，不再是飞行策略实现的一种变体，要是RubberDuck也能因满足Fly特型约束，再次充当Duck自己的“翅膀”F，组合成一个新Duck，那这是什么Duck？闹笑话了，一向以“严格”著称的Rust可不喜欢这样做。看起来Duck会飞，和飞行策略的Fly特型有所不同，读者可自行感受，那如何约束Duck，让别人知道Duck也是可飞行的一个类型呢？可以使用AsRef，让鸭子实现<code>AsRef&lt;F: Fly&gt;</code>，意为“Duck拥有飞行的策略”，鸭子自然也会飞，能做所有会飞的类型可以做的事情。</p>
<pre><code>fn fly_to_do_sth&lt;T, F&gt;(fly_animal: &amp;mut T) 
where
    T: AsRef&lt;F&gt;,
    F: Fly,
{
    // Duck也可以作为fly_animal来执行此函数了
}
</code></pre>
<p>注意，这里AsRef跟Deref的区别。AsRef可以实现多次，到不同类型的借用转换，比如Duck同时AsRef&lt;F: Fly&gt;和AsRef&lt;Q: Quack&gt;；而Deref只能实现一次到一个主Target的类型转换，而Fly和Quack无论哪个行为，明显都不足以让Duck为其实现Deref，它的父类动物结构，才值得Duck使用Deref。</p>
<h2>小结</h2>
<p>初识策略模式时，觉得妙不可言，但它其实没提策略模式那逐渐不可控的后续演化，源于为策略模式的复合类型Duck扩展行为时，并非所有Duck都该有这些扩展行为了，它们很可能是某些鸭子独有的，主要原因是动多态造成了“类型丢失”，而解决办法还没法令人满意！因此，策略模式适合后续不再演化的场景。能应对后续演化的，还得是类型完整的静多态思路。</p>
<p>编程的一大挑战就是为了应对变化，开发者知道的招式变化越多，应对的就越从容，使用看起来正确实际上却会逐渐失控的招式，只会味道越来越坏。变化就是“可扩展性”，谈到“可扩展性”，面向对象说这个我熟，“可扩展性”就是面向对象的目标之一啊！先别轻信，完美应对变化可不容易，即便资深的面向对象专家，都不敢说他写的每个东西都真能满足“单一职责”。。单一职责的足够“原子化”吗？面向对象思想有个老毛病，就是不够具体，让人抓不到，又让人以为抓到了，实际上是面向对象规定的东西，包括它的评论、解释大都泛泛而谈，没有一个度，很难意见统一。</p>
<p>（强调一下：因每个人理解层次不同，这一系列文章无意引战，也不想批评C++，只要C++想，就能实现Rust一样的效果，毕竟现代C++无所不能的。面向对象有些问题值得指出、批评，但个人还是认可面向对象的结构之美。这些文章，仅供大家友好交流Rust和面向对象技术，若有迁移一个面向对象项目到Rust重新实现的需求，那可能会有帮助，欢迎大家友好讨论！）</p>
<p>（原创不易，请在征得作者同意后再搬运，并注明出处！）</p>
2024-02-22T18:27:43.622188055+08:00 - 文章标题：Rust与面向对象（二）
2024-02-22T18:27:43.622297835+08:00 - 文章内容：<h2>模板方法</h2>
<p>Rust提供了trait，类似于面向对象的接口，不同的是，将传统面向对象的虚函数表从对象中分离出来，trait仍然是一个函数表，只不过是独立的，它的参数self指针可以指向任何实现了该trait的结构。</p>
<p>从对象中分离出虚函数表的trait，带来了使用上与面向对象一些根本的不同，这在我看来算是“很大”的不同了。让我们以模版方法设计模式为例来感受一下。先想一下，rust怎么依赖trait和结构继承，实现模板方法？所谓模板方法，就是父类留一个空白方法作为虚函数，交给子类实现，这样子类只负责不同的算法部分，是面向对象中很基础很常用的手法了。用Rust语言照葫芦画瓢先描述一下大概框架，如下：</p>
<pre><code>/// 一个父类A
struct A {
    ...
}

impl A {
    fn do_step1_common(&amp;mut self) { ... }

    // 缺省实现，留给子类实现，如果是C++/Java这类面向对象语言，很容易。若是Rust，该怎么搞？
    fn do_step2_maybe_different(&amp;mut self) { ... }

    fn do_step3_common(&amp;mut self) { ... }

    pub fn do_all_steps(&amp;mut self) {
        self.do_step1_common();
        self.do_step2_maybe_different();
        self.do_step3_common();
    }
}

// 具体的某个子类实现
struct A1 {
    a: A,
    ...
}

impl A1 {
    // 开始实现
    fn do_step2_maybe_different(&amp;mut self) {
        // A1提供一种实现
    }
}
</code></pre>
<p>不瞒大家，我初识rust时就被这样一个面向对象上的简单案例，用rust实现给难住了！当时卡在父类看起来像是一个完整的类型，Rust怎么能未卜先知调用子类的方法呢？</p>
<p>其实，Rust要想实现这种效果，不能A1继承A这种了，而是A包含A1子类来实现，反着来，将不同的实现单独拆出来作为trait，再交给子类实现。</p>
<pre><code>trait DoStep2 {
    fn do_step2_maybe_different(&amp;mut self);
}

/// 另一个父类B
struct B&lt;T&gt; {
    t: T, // 或者Box&lt;&amp;dyn DoStep2&gt;
    ...
}

impl&lt;T&gt; B&lt;T&gt; {
    fn do_step1_common(&amp;mut self) { ... }

    fn do_step3_common(&amp;mut self) { ... }
}

impl&lt;T: DoStep2&gt; B&lt;T&gt; {
    pub fn do_all_steps(&amp;mut self) {
        self.do_step1_common();
        self.t.do_step2_maybe_different();
        self.do_step3_common();
    }
}

/// 具体的子类实现
struct B1 {
    ...
}

impl DoStep2 for B1 {
    fn do_step2_maybe_different(&amp;mut self) {
        // B1提供一种实现
    }
}

// 这样，
// B&lt;B1&gt; 相当于面向对象中的 A1
// B&lt;B2&gt; 相当于面向对象中的 A2
</code></pre>
<p>感觉不错，看起来颇为妥当，这种方式已经能在适合它的场景中工作，也是模板方法的体现。对比下，<code>A</code>、<code>B</code>都不是完整的父类实现，<code>A1</code>、<code>B&lt;B1&gt;</code>才是真正的具体类型，且它们都包含了父类的结构，虽然<code>B&lt;B1&gt;</code>的写法有点不合常规。若子类还拥有自己的独立的扩展结构的话，那Rust这种方式更优雅一些，拆分的更原子、更合理。实践中，往往不会这么完美的套用，会复杂很多，比如子类作为具体类型，想访问父类的成员，才能配合完成<code>do_step2</code>，Rust又该怎么做？面向对象的this指针则轻松支持。Rust不可能让<code>B1</code>再直接包含<code>B</code>，那样循环包含了，只能用引用或者指针来存在<code>B1</code>里面，但这样的话，岂不是太麻烦了，循环引用/包含都是我们极力避免的东西，麻烦到都想放弃模板方法了！</p>
<p>为何会有这种差异？因为面向对象的子类this指针其实指向的是整体，子类的函数表是个本身就包含父类的整体；而上述为<code>B1</code>实现DoStep2 trait的时候，self指向的仅仅是<code>B1</code>，并不知道<code>B</code>的存在。那怎么办？得让self指向整体<code>B&lt;B1&gt;</code>，那为<code>B&lt;B1&gt;</code>实现DoStep2行不行？像下面这样：</p>
<pre><code>impl DoStep2 for B&lt;B1&gt; {
    fn do_step2_maybe_different(&amp;mut self) {
        // 这里self可以访问“父类”B的成员了
    }
}
</code></pre>
<p>但回过头来，<code>B::do_all_steps(&amp;mut self)</code>就没法在“父类”B中统一实现了，因为<code>B&lt;T&gt;</code>在<code>B&lt;B1&gt;</code>具象化之前，还不知道哪来的<code>do_step2</code>，因此要在<code>impl B&lt;B1&gt;</code>中实现，每个不同的具像化的子类都得单独实现相同的<code>do_all_steps</code>!你能接受不？</p>
<p>也许你能接受，为每个<code>B&lt;B1&gt;</code>、<code>B&lt;B2&gt;</code>...重复拷贝一遍各自的<code>do_all_steps</code>！本文基于专业探讨，还是要寻找一下编写通用的<code>do_all_steps</code>方法的，有没有？当然是有的，前提是，你得把<code>do_step1_common</code>，<code>do_step3_common</code>也得trait化，然后在用一个trait组合限定搞定，如下：</p>
<pre><code>trait DoStep1 {
    fn do_step1_common(&amp;mut self);
}

trait DoStep3 {
    fn do_step2_common(&amp;mut self);
}

// 因为B&lt;T&gt;是泛型，只需为泛型编码实现一次DoStep1、DoStep3就行
impl&lt;T&gt; DoStep1 for B&lt;T&gt; { ... }
impl&lt;T&gt; DoStep3 for B&lt;T&gt; { ... }


// 最后，实现通用的do_all_steps，还得靠泛型。
// 此时，B&lt;B1&gt;已经满足T，会为其实现下面的函数
// 可以这样读：为所有实现了DoStep1/DoStep2/DoStep3特质的类型T实现do_all_steps
impl&lt;T&gt; T 
where
    T: DoStep1 + DoStep2 + DoStep3
{
    pub fn do_all_steps(&amp;mut self) {
        self.do_step1_common();
        self.do_step2_maybe_different();
        self.do_step3_common();
    }
}
</code></pre>
<p>如何，这样应该能接受了吧。Rust通过把问题解构的更细粒度，完成了任务。客观对比下，面向对象的实现还是简单些，父类的<code>do_step1</code>和<code>do_step3</code>函数永远指向了同一个实现，而Rust靠泛型应该是指向了3个不同的实现？不知道编译期有没有优化，盲猜应该有。可以说语法如此，Rust只能做到如此了。与面向对象的模板方法相比，最后一点小瑕疵，就是要多定义<code>DoStep1</code>、<code>DoStep2</code> 2个trait，并用一个<code>T: DoStep1 + DoStep2 + DoStep3</code>通用类型包含同样实现了<code>DoStep1 + DoStep2 + DoStep3</code>的<code>B&lt;T&gt;</code>，进而代表它。可我们想仅仅为<code>B&lt;T&gt;</code>类型实现，其他类型也不太可能这样实现了，一个T则把范围不必要地扩大了。要是能按照我们想要的，就仅为<code>B&lt;T&gt;</code>且实现了<code>DoStep2</code>的<code>B&lt;T&gt;</code>来实现<code>do_all_steps</code>，就完美了。要做到此种程度，必须能对自身Self进行限定，如下：</p>
<pre><code>/// 可以这样读：为所有自身实现了DoStep2的B&lt;T&gt;实现do_all_steps
impl&lt;T&gt; B&lt;T&gt;
where
    Self: DoStep2
{
    pub fn do_all_steps(&amp;mut self) {
        self.do_step1_common();
        self.do_step2_maybe_different();
        self.do_step3_common();
    }
}
</code></pre>
<p>这种写法还真可以，也不用额外定义DoStep1、DoStep3了，因为本身<code>B&lt;T&gt;</code>已经有<code>do_step1_common</code>/<code>do_step3_common</code>的实现了，Rust最新的稳定版就支持这样写！</p>
<p>一段完整的Rust代码，可以参考<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=b80de6d4e6d75bf59bb37db386264fed" rel="noopener noreferrer">这里：https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=b80de6d4e6d75bf59bb37db386264fed</a></p>
<p>一个小小的模板方法，Rust分离出2种不同的方式，这是模板方法设计模式都没提到的，2种方式还各有韵味。从定义的顺序上，C++的模板方法，是 <strong>“子类后续扩展父类”</strong> ，Rust的模板方法，则是 <strong>“父类提前包含子类泛型”</strong> ，写法上还真是一开始不太好扭过来。可一旦扭转过来，发现Rust挺强，仍不失面向对象技巧。</p>
<p>反观面向对象，一个模板方法案例，让大家看到了些许面向对象的束缚，其实也无伤大雅，面向对象也能用纯组合的方式实现模板方法，也不用继承，如果需要组合的对象再通过构造动态传递进来，那就跟策略模式很像了，这种组合传递来的对象不止一个时，就是策略模式！然后，让我想起了一个小争论，子类应该严格不准访问父类的成员，让父类的变化完全掌控在父类手中。面向对象的确可以做到，全部private。但Rust的处理方式，显示出了其对这些细节的语法表达更合乎逻辑。</p>
<h2>总结</h2>
<p>模板方法是面向对象虚函数继承的基本应用，是面向对象很多设计模式的基础，如装饰器模式。一篇讲解下来，Rust从一开始别别扭扭到更好地支持模板方法，其实能体会到，Rust强迫你去拆解，即便都是同一个模板方法，但不同的细节要求，子类是否需要访问父类，都有不同的处理变化，分出来的形式还更严格。写到最后，Rust都感觉不到面向对象那味了，那是什么味？</p>
2024-02-22T18:27:43.622348091+08:00 - 文章标题：Rust与面向对象（一）
2024-02-22T18:27:43.622438082+08:00 - 文章内容：<h2>前言</h2>
<p>我个人是修炼了多年的面向对象技术，这一点，相信很多同道中人跟我一样，经历了面向对象的洗礼，毕竟面向对象技术从上世纪七十年代就开始展露头角，是当时的先进编程思想，其理念符合人类对事物的认知方式；近二十多年，都是面向对象技术盛行。面向对象发展至今，有很多优美设计，诸如经典面向对象设计模式中的策略模式、装饰器模式等等，做UI系统时，组合模式+装饰器模式的绘制、ui树管理，别提多优美了，职责链处理UI交互事件，完美应对事件冒泡，简单又令人惊叹。继承、封装、多态，从它们被发明以来，一直有它伟大的意义。要说，Rust超越了面向对象，那内心还得问一句，装饰器在Rust中怎么实现，能不能实现的比面向对象更简单、易懂且优雅？当然，面向对象，也有其缺点，为人诟病的有对象间的相互调用关系混乱，将对象视为有限状态机封装导致的不利于并行等，这些表明面向对象不似它宣传的那么好，并不适合所有场景，这些场景呼唤更好的解决方案。</p>
<p>在Rust社区有不少对面向对象的讨论，这种讨论非常有意义，体现了某些编程设计上本质的东西，这也是我喜欢Rust这门语言的原因之一。作为Rust初学者，一开始我还不是很了解Rust所谓的“超越面向对象”体现在哪里，只能说一知半解、半推半就。一开始会觉得Rust对面向对象批判之后，然后就提了个Trait+Enum和类型的解决方案，就这？代替面向对象那么多设计模式的方案也没多少，就一个更严格的NewType状态机？面向对象可不止一个状态机模式！不免让人生疑：Enum在module之外，其子类扩展性何在？面向对象的诸多优秀设计，还能在Rust语言上良好表达吗？</p>
<p>有时会觉得，面向对象有时候比Rust的Enum、Trait表达能力差的并不多，甚至更好，却足以引发舌战；Rust有时比面向对象强的也不多，也足以引发对面向对象的批判。这种争论本身也没啥好不好，争论多了，自然就能发现什么了。但有时候，我们就是这么容易争论，而实际上，我们连对争论的本质问题是什么，都没搞清。</p>
<p>对Rust入门以后，再看Rust的设计，能意外地发现它想表达的东西了，很开心。现在，把这些对面向对象和Rust理解整理对比下，很多文章都介绍过，这一系列文章，将采用Rust尝试实现各种面向对象技巧的方式来叙述，目标是寻找Rust达成这些技巧的替代方案，同时搞清楚面向对象设计的问题在哪里，及Rust的改良又体现在哪里。
并不否定面向对象技术，也不会通过贬低它来宣示Rust的好，各有值得学习的东西，都有自己适用的领域。非要说的话，面向对象技术现在更普及易懂，是大部分编程人员的必修课，应该沉淀为基操；Rust则更艰涩高深，但其逻辑表达确实更基础，潜力更大。</p>
<h2>面向对象之结构继承</h2>
<p>一切先从最简单的开始。面向对象届有句老话：“多用组合，少用继承”，被奉为圭臬，很多对代码的批评就源自于没遵守它。让我们对比一下：</p>
<pre><code>struct A {
    x: int,
}

struct B1 extends A {
    y: int,
}

struct B2 {
    a: A,
    y: int,
}

</code></pre>
<p>B1好，还是B2好？其实无法回答的。然而，看下B1、B2这两者的内存布局，会惊讶的发现，它们其实是一样的。</p>
<p>看到这里，我第一次怀疑，这么多年的“继承” vs “组合”的争论，是否有必要，我们怎么会这么傻，为了一个相同的东西，还能喋喋不休了这么多年🐶。</p>
<p>不过，有人可能会问了，这种只是内存布局一样，实际上能一样吗，B1、B2对x的访问是不一样的。</p>
<pre><code>// B1是这样访问x的
int get_x = b1.x;

// 而B2是通过a访问的
int get_x = b2.a.x;
</code></pre>
<p>确实不一样，但实际上<code>b2.x</code>可以看成<code>b2.a.x</code>的语法糖。到最终编译到的汇编语言层面，真也的确如此。Rust语言可以轻松使用Deref特质实现该语法糖，连调用A的方法都能一并简化。</p>
<pre><code>impl Deref for B2 {
    type Target = A;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.a
    }
}
</code></pre>
<p>所以，别在讨论，该用组合还是该用继承了！继承本身就是组合，还有啥好讨论的，就算是多继承的概念，也等同于组合多个不同结构。</p>
<p>了解到这一点，对底层而言，"is-a"就是"has-a"，高级语言为其发明了“继承”，此时显的多此一举。底层结构上都一样，所以go语言的结构继承，看上去就是组合，rust亦如此。继承就是一种特殊的组合！</p>
<p>但组合可不仅仅是继承，组合变化更多。组合还可以包含一个“指针”型结构，"has-a-ref"，这在链表、树这种自包含结构里尤其关键；组合还能包含一个集合——"has-many"，"has-a"都可以看成是"has many"的特例，比如树包含不止一个枝干。</p>
<pre><code>// 表达能力上，B3更强，B1、B2都可以用B3来表示，B2不过是B3中包含长度为1的向量
struct B3 {
    a: Vec&lt;A&gt;,
    y: int,
}
</code></pre>
<p>面向对象的一个尴尬就是，本身继承的底层结构是组合，功能上也不如组合，却把“继承”提高到“三大概念”的核心层次，因小失大，以偏概全。从这点看，"has-a"拥有相同结构，加上"is-a"的语法糖，所以go、rust，概念更少，还能表达出“继承”，亦不失组合的含义，更受欢迎。</p>
<p>但话说回来，面向对象，其实有个关键的语法习惯改进，即以对象为主语的调用方式，类自然语言的“主-谓”或者“主-谓-宾”语句，终于不用主语倒置了，现在大部分语言都是默认如此了，Rust也是如此。这时候再考虑继承，若论直接使用父类的谓词行为，则是“is-a”的继承独有的，“has-a”/“has-a-ref”都要借助语法糖或者重新实现父类接口来表达这种"is-a"父类的行为。“has-many”如果也能表现出"is-a"的特性，那就是经典的组合模式了。不过大多时候是“has-many”表现不出“is-a”的特性，仅仅是一种集合管理。</p>
<pre><code>impl DrawWidget for A {
    fn draw(&amp;self, canvas: &amp;mut Canvas) {
        ...
    }
}

// B1已天然实现了DrawWidget，仍可选覆盖实现
// impl DrawWidget for B1 { ... }

// B2则需要实现“is-a”。在Rust语言里，即便B2实现了Deref，也不代表着
impl DrawWidget for B2 {
    fn draw(&amp;self, canvas: &amp;mut Canvas) {
        self.a.draw(canvas);
        // draw y
    }
}

// B3是“has-many”，但本身也可以看成是一个Widget的话，那就是面向对象中经典的组合模式
impl DrawWidget for B3 {
    fn draw(&amp;self, canvas: &amp;mut Canvas) {
        for child in self.a {
            child.draw(canvas);
        }
        // draw y
    }
}
</code></pre>
<p>总结一下，"has"包括</p>
<ul>
<li>"has-a"
<ul>
<li>若意义等同于"is-a"，则为继承；包括"has-(a,b)"等同于"is-(a,b)"型，多继承概念</li>
<li>若不等同于"is-a"，则为简单的包含关系，如一个数据包包含包头和包体，一个分数包含分子和分母等</li>
<li>有时候，即可以用继承，也可以用组合，比如代理模式，就有继承代理和组合代理2种，其结构本相同，何须再分出你我，这就是面向对象不必要的高级概念复杂化</li>
<li>"has-a"还可以是"has-a-ref"，C/C++中包含一个其他结构的指针成员，内存结构不同于继承，却也能形如继承，是组合的一种，链表这类自包含结构必备</li>
</ul>
</li>
<li>"has-many"
<ul>
<li>若还有跟"is-a"一样的特性，就是组合模式</li>
<li>普通的集合管理</li>
</ul>
</li>
</ul>
<p>回到面向对象语义/语言，要问该选哪一种，就看那种能更精准地表达，猫是动物、鸭子是动物，这种就是继承，猫、鸭子继承了动物，肯定比猫、鸭子包含一个动物结构好。而树包括枝干，就是包含关系好。高级语言，对同一结构不同表达，怎么方便人理解怎么来，如此而已。</p>
<p>在Rust语言中，则没了继承的概念，都是组合。因为Rust的Deref，让Rust保留了继承的部分功能性，并没有关闭面向对象的大门。但需注意，B2并未因Deref自动继承实现A所有的特质。Rust舍弃了高级语言复杂的“继承”概念，把底层是什么样就是什么样的组合原汁原味地展现出来，同时保留下其他变化，既继承的弊端可以被摒弃替换成组合或者特质实现的变化，这种变化也许才是那更常见的大多数情况，废除“继承”可能会是未来语言的标准做法。</p>
<h2>结束语</h2>
<p>本篇到这里暂时就结束了，因为篇幅不宜太长，先行文至此，一篇围绕一个小主题。本文仅仅讨论了面向对象的结构继承。面向对象的结构继承，其实狭隘了，从内存结构布局上看，仅仅是组合的一种特例，还不如说成就是组合，组合意义更广泛。有时候，不妨把底层的概念直接暴露出来，也没增加复杂度，理解上会更直白。</p>
<p>Rust也为结构继承留下了Deref的方案，不过请留意，Deref并没让子类自动继承实现父类的特型，只是一个解引用的语法糖，而且一个结构只能实现一次Deref到一个Target。Deref并非仅为结构继承而生，Rust也没怎么提倡用Deref式的继承，官方文档从来没说它是用来对标“继承”的，倒是不少开源项目，拿它映射继承，如果符合“is-a”的意义，还挺适用的。</p>
<p>继承仍有些问题、冲突没展示出来，后面再继续探讨。包括Deref这种具备关联类型的特质，它到后面也不再仅是一个语法糖，在表达实现逻辑语义时，子类没必要实现父类的特型，在特型限定时它们将有更丰富的逻辑表达意义。</p>
2024-02-22T18:27:43.622476322+08:00 - end
